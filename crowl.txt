private boolean importCsvToDatabaseBatch(Path csvFilePath, String tableName, Connection connection, char delimiter) throws Exception {
    long totalRecords = fileIteration.getRows(); // Вычисляем количество записей
    int totalSteps = (int) Math.ceil((double) totalRecords / BATCH_SIZE); // Шаги прогресса = батчи

    int stepsCompleted = 0;

    // Выводим прогресс бар с сообщением
    String message = "Импорт данных в базу для файла " + csvFilePath.getFileName();
    printMsgWithProgressBar(message, totalSteps, 50); // 50 — длина прогресс бара, можно настроить

    try (Reader reader = Files.newBufferedReader(csvFilePath);
         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withDelimiter(delimiter).withFirstRecordAsHeader())) {

        List<String> headers = csvParser.getHeaderNames().stream()
                .flatMap(header -> splitHeader(header.trim()))
                .map(header -> "\"" + header.trim() + "\"")
                .collect(Collectors.toList());
        headers.add("\"iteration_id\"");
        String insertSQL = generateInsertSQL(tableName, headers);
        int iteration_id = getIterationId(csvFilePath);

        try (PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {
            List<CSVRecord> records = csvParser.getRecords();
            int count = 0;

            for (CSVRecord record : records) {
                for (int i = 0; i < headers.size(); i++) {
                    String value;
                    if (i == headers.size() - 1) {
                        value = String.valueOf(iteration_id);
                    } else {
                        value = record.get(i);
                    }
                    if (!getIgnoreGaps().equals("active") && (value == null || value.trim().isEmpty())) {
                        description = "Пропуск данных";
                        return false;
                    } else {
                        if (i == headers.size() - 1) {
                            preparedStatement.setInt(i + 1, iteration_id);
                        } else {
                            preparedStatement.setString(i + 1, value);
                        }
                    }
                }

                preparedStatement.addBatch();
                count++;
                if (count % BATCH_SIZE == 0) {
                    preparedStatement.executeBatch();
                    stepsCompleted++;
                    printMsgWithProgressBar(message, stepsCompleted, totalSteps); // Обновляем прогресс бар
                }
            }

            preparedStatement.executeBatch(); // Выполнение оставшихся записей
            if (count % BATCH_SIZE != 0) {
                stepsCompleted++;
                printMsgWithProgressBar(message, stepsCompleted, totalSteps); // Обновление для последнего батча
            }
        }
    } catch (Exception e) {
        String message = "importCsvToDatabaseBatch: Ошибка при batch вставке данных в бд -> ";
        log.error(ExceptionFilter.unwindMessages(message, e));
        description = ExceptionFilter.unwindMessages(message, e);
        throw new Exception(message + e.getMessage(), e);
    }

    System.out.println(); // Перенос на новую строку после завершения
    return true;
}

public static void printMsgWithProgressBar(String message, int stepsCompleted, int totalSteps) throws Exception {
    int length = 50; // Длина прогресс бара
    char incomplete = '░';
    char complete = '█';

    // Выводим сообщение
    System.out.println(message);

    // Рисуем прогресс-бар
    for (int i = 0; i <= length; i++) {
        for (int j = 0; j < length; j++) {
            if (j < (i * totalSteps / length)) {
                System.out.print(complete); // Заполненная часть
            } else {
                System.out.print(incomplete); // Не заполненная часть
            }
        }
        System.out.print("\r"); // Перезаписываем в той же строке
        Thread.sleep(50); // Задержка для плавности обновления (можно настроить)
    }

    // Завершаем вывод прогресса
    System.out.println();
}
