Чтобы добавить отображение прогресса импорта файлов с использованием `ProgressBar`, можно использовать общий подход с передачей статуса выполнения и шагов через асинхронный механизм. Например, вы можете внедрить интерфейс `ProgressReporter` или аналогичное решение. Вот пример реализации:

1. **Создаем интерфейс для прогресса:**
```java
public interface ProgressReporter {
    void onProgress(String fileName, int currentStep, int totalSteps);
}
```

2. **Реализуем ProgressBar и подключаем его к импорту:**
Создайте отдельный класс `ConsoleProgressReporter`, который будет выводить прогресс в консоль.

```java
public class ConsoleProgressReporter implements ProgressReporter {
    @Override
    public void onProgress(String fileName, int currentStep, int totalSteps) {
        int progressPercentage = (int) (((double) currentStep / totalSteps) * 100);
        System.out.printf("Импорт файла %s: %d%% (%d из %d шагов)%n", fileName, progressPercentage, currentStep, totalSteps);
    }
}
```

3. **Добавляем ProgressReporter в `FileImporterService`:**
Обновите класс `FileImporterService`, чтобы принимать и использовать `ProgressReporter`.

```java
@Service
@Slf4j
public class FileImporterService {
    private final Set<String> processedFiles = ConcurrentHashMap.newKeySet();
    private final ProgressReporter progressReporter;

    public FileImporterService(ProgressReporter progressReporter) {
        this.progressReporter = progressReporter;
    }

    private boolean importCsvToDatabaseBatch(Path csvFilePath, String tableName, Connection connection, char delimiter) throws Exception {
        try (Reader reader = Files.newBufferedReader(csvFilePath);
             CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withDelimiter(delimiter).withFirstRecordAsHeader())) {

            List<CSVRecord> records = csvParser.getRecords();
            int totalSteps = records.size();
            int currentStep = 0;

            try (PreparedStatement preparedStatement = connection.prepareStatement(generateInsertSQL(tableName, csvParser.getHeaderNames()))) {
                for (CSVRecord record : records) {
                    // Заполняем параметры для вставки
                    for (int i = 0; i < record.size(); i++) {
                        preparedStatement.setString(i + 1, record.get(i));
                    }
                    preparedStatement.addBatch();
                    currentStep++;

                    // Выполняем батч каждые N записей
                    if (currentStep % BATCH_SIZE == 0) {
                        preparedStatement.executeBatch();
                        progressReporter.onProgress(csvFilePath.getFileName().toString(), currentStep, totalSteps);
                    }
                }
                preparedStatement.executeBatch();
            }

            progressReporter.onProgress(csvFilePath.getFileName().toString(), totalSteps, totalSteps);
            return true;
        }
    }
}
```

4. **Подключение в Spring-контексте:**
Зарегистрируйте `ProgressReporter` в конфигурации вашего приложения.

```java
@Configuration
public class AppConfig {
    @Bean
    public ProgressReporter progressReporter() {
        return new ConsoleProgressReporter();
    }
}
```

5. **Вывод в процессе работы:**
Теперь во время импорта данных прогресс будет отображаться в консоли. Например:
```
Импорт файла example.csv: 20% (100 из 500 шагов)
Импорт файла example.csv: 40% (200 из 500 шагов)
Импорт файла example.csv: 100% (500 из 500 шагов)
```

Вы также можете интегрировать прогресс в веб-интерфейс, если используете `WebSocket` или другой механизм передачи данных в реальном времени.