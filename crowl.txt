@Service
public class FolderCleaner {
    private static final Logger logger = LoggerFactory.getLogger(FolderCleaner.class);

    @Value("${cleaner-properties.folderPath}")
    private String watchedDirectoryPath;
    private final FileCategoryRepository fc;

    public FolderCleaner(FileCategoryRepository fc) {
        this.fc = fc;
    }

    @Scheduled(cron = "${cleaner-properties.schedulerCron}")
    public void cleanFolder() {
        Path watchedDirectory = Paths.get(watchedDirectoryPath);
        try {
            Files.list(watchedDirectory)
                    .forEach(this::deleteExpiredFile);
        } catch (IOException e) {
            logger.error("Ошибка при очистке директории: {}", e.getMessage());
        }
    }

    private void deleteExpiredFile(Path path) {
        String fileName = path.getFileName().toString();
        String fileExtension = fileName.substring(fileName.lastIndexOf(".") + 1);
        String fileMask = fileName.replaceAll("\\d", "").replace("." + fileExtension, "");

        int daysToExpire = fc.selectDaysToExpireByNameMask(fileMask, fileExtension);
        
        if (daysToExpire >= 0) {
            try {
                BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
                Instant creationInstant = attrs.creationTime().toInstant();
                LocalDateTime creationTime = LocalDateTime.ofInstant(creationInstant, ZoneId.systemDefault());
                long daysSinceCreation = ChronoUnit.DAYS.between(creationTime, LocalDateTime.now());
                
                if (daysSinceCreation > daysToExpire) {
                    Files.delete(path);
                    logger.info("Удален файл {}", fileName);
                }
            } catch (IOException e) {
                logger.error("Ошибка при удалении файла {}: {}", fileName, e.getMessage());
            }
        }
    }
}
