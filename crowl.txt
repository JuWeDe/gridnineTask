public class FileCategoryRepository {
    private final DataSource fileCategoriesDataSource;
    private List<FileCategory> categories;

    public FileCategoryRepository(DataSource fileCategoriesDataSource) {
        this.fileCategoriesDataSource = fileCategoriesDataSource;
        cacheCategories();  // можно назвать loadCategories
    }

    private void cacheCategories() {
        logger.info("Начало загрузки категорий...");
        categories = selectAllFileCategories();  // сохраняем категории в список
        logger.info("Загрузка категорий завершена. Всего категорий: {}", categories.size());
    }

    // Поиск категории по маске имени и расширению файла
    public FileCategory findByNameMaskAndExtension(String nameMask, String extension) {
        for (FileCategory category : categories) {
            if (category.getNameMask().equals(nameMask) && category.getExtensions().equals(extension)) {
                return category;
            }
        }
        return null;  // если категория не найдена
    }
}



public class FolderCleaner {
    private FileCategoryRepository fc;

    // Другие методы...

    private void deleteExpiredFile(Path path) {
        String fileName = path.getFileName().toString();
        logger.debug("Обработка файла: {}", fileName);

        String fileExtension = fileName.substring(fileName.lastIndexOf(".") + 1);
        String fileMask = fileName.replaceAll("\\d", "").replace("." + fileExtension, "");

        // Поиск категории по маске имени и расширению файла
        FileCategory fileCategory = fc.findByNameMaskAndExtension(fileMask, fileExtension);

        if (fileCategory != null) {
            int daysToExpire = fileCategory.getDaysToExpire();

            logger.info("Файл {} имеет срок жизни {} дней", fileName, daysToExpire);
            try {
                BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
                Instant creationInstant = attrs.creationTime().toInstant();
                LocalDateTime creationTime = LocalDateTime.ofInstant(creationInstant, ZoneId.systemDefault());
                long daysSinceCreation = ChronoUnit.DAYS.between(creationTime, LocalDateTime.now());

                if (daysSinceCreation > daysToExpire) {
                    Files.delete(path);
                    logger.info("Удален файл {}", fileName);
                } else {
                    logger.info("Файл {} еще не истек", fileName);
                }
            } catch (IOException e) {
                logger.error("Ошибка при удалении файла {}: {}", fileName, e.getMessage());
            }
        } else {
            logger.warn("Срок жизни для файла {} не найден", fileName);
        }
    }
}

