@Repository
public class FileCategoryRepository {

    private static final String SELECTDAYS_TO_EXPIRE_BY_NAME_MASK = "SELECT days_to_expire FROM file_categories WHERE name_mask LIKE ? AND extensions = ?";
    private static final String SELECTFILE_CATEGORY_BY_NAME_MASK = "SELECT * FROM file_categories WHERE name_mask = ? AND extensions = ?";
    
    private final DataSource fileCategoriesDataSource;
    private Map<String, Integer> cache = new HashMap<>();

    public FileCategoryRepository(DataSource fileCategoriesDataSource) {
        this.fileCategoriesDataSource = fileCategoriesDataSource;
        loadAllCategoriesToCache(); // Загружаем кэш при создании объекта
    }

    private void loadAllCategoriesToCache() {
        try (Connection connection = fileCategoriesDataSource.getConnection();
             PreparedStatement statement = connection.prepareStatement("SELECT name_mask, extensions, days_to_expire FROM file_categories");
             ResultSet resultSet = statement.executeQuery()) {
            
            while (resultSet.next()) {
                String nameMask = resultSet.getString("name_mask");
                String extensions = resultSet.getString("extensions");
                int daysToExpire = resultSet.getInt("days_to_expire");
                cache.put(nameMask + "|" + extensions, daysToExpire);
            }
        } catch (SQLException e) {
            // Логирование ошибки
        }
    }

    public int selectDaysToExpireByNameMask(String nameMask, String extension) {
        return cache.getOrDefault(nameMask + "|" + extension, -1);
    }

    public int selectFileCategoryByNameMask(String nameMask, String extension) {
        // В этом методе также можно использовать кэш
        // Для получения категории, если необходимо
        return 0; // Замените на нужную логику
    }
    
    // Остальные методы остаются без изменений...
}

@Service
public class FolderCleaner {
    private static final Logger logger = LoggerFactory.getLogger(FolderCleaner.class);

    @Value("${cleaner-properties.folderPath}")
    private String watchedDirectoryPath;
    private final FileCategoryRepository fc;

    public FolderCleaner(FileCategoryRepository fc) {
        this.fc = fc;
    }

    @Scheduled(cron = "${cleaner-properties.schedulerCron}")
    public void cleanFolder() {
        Path watchedDirectory = Paths.get(watchedDirectoryPath);
        try {
            Files.list(watchedDirectory)
                    .forEach(this::deleteExpiredFile);
        } catch (IOException e) {
            logger.error("Ошибка при очистке директории: {}", e.getMessage());
        }
    }

    private void deleteExpiredFile(Path path) {
        String fileName = path.getFileName().toString();
        String fileExtension = fileName.substring(fileName.lastIndexOf(".") + 1);
        String fileMask = fileName.replaceAll("\\d", "").replace("." + fileExtension, "");

        int daysToExpire = fc.selectDaysToExpireByNameMask(fileMask, fileExtension);
        
        if (daysToExpire >= 0) {
            try {
                BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
                Instant creationInstant = attrs.creationTime().toInstant();
                LocalDateTime creationTime = LocalDateTime.ofInstant(creationInstant, ZoneId.systemDefault());
                long daysSinceCreation = ChronoUnit.DAYS.between(creationTime, LocalDateTime.now());
                
                if (daysSinceCreation > daysToExpire) {
                    Files.delete(path);
                    logger.info("Удален файл {}", fileName);
                }
            } catch (IOException e) {
                logger.error("Ошибка при удалении файла {}: {}", fileName, e.getMessage());
            }
        }
    }
}

