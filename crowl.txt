Если вы выполняете обработку всех батчей в одной транзакции, это объясняет проблему. Дело в том, что пока транзакция не завершена, процесс вставки данных фактически не выполняется, а ваш прогресс обновляется только после того, как вся операция завершена.

Чтобы корректно отображать прогресс, нужно учитывать следующее:

1. **Фактическая обработка должна быть разбита на шаги**: Если вы используете транзакцию, прогресс будет "заморожен", пока транзакция не завершится. Чтобы решить эту проблему, можно обновлять прогресс перед добавлением батча в транзакцию (но не коммитить данные до завершения всех шагов).

2. **Ограничить вывод на основе количества батчей**: Убедитесь, что прогрессбар обновляется на основе количества батчей, а не строк. 

---

### Обновленный подход

Модифицируем цикл вставки данных, чтобы обновление прогрессбара происходило после добавления каждого батча в транзакцию:

#### Изменения в `importCsvToDatabaseBatch`
```java
private boolean importCsvToDatabaseBatch(Path csvFilePath, String tableName, Connection connection, char delimiter) throws Exception {
    ProgressBarService progressBarService = new ProgressBarService(csvFilePath.getFileName().toString(), totalBatchCount); // totalBatchCount = (totalRows / BATCH_SIZE)

    try (Reader reader = Files.newBufferedReader(csvFilePath);
         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withDelimiter(delimiter).withFirstRecordAsHeader())) {
        
        List<String> headers = csvParser.getHeaderNames().stream()
                .flatMap(header -> splitHeader(header.trim()))
                .map(header -> "\"" + header.trim() + "\"")
                .collect(Collectors.toList());
        headers.add("\"iteration_id\"");

        String insertSQL = generateInsertSQL(tableName, headers);
        int iteration_id = getIterationId(csvFilePath);

        try (PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {
            List<CSVRecord> records = csvParser.getRecords();
            int count = 0;
            int totalBatchCount = (records.size() + BATCH_SIZE - 1) / BATCH_SIZE;

            for (CSVRecord record : records) {
                for (int i = 0; i < headers.size(); i++) {
                    String value = i == headers.size() - 1
                            ? String.valueOf(iteration_id)
                            : record.get(i);

                    if (!getIgnoreGaps().equals("active") && (value == null || value.trim().isEmpty())) {
                        description = "Пропуск данных";
                        return false;
                    }

                    if (i == headers.size() - 1) {
                        preparedStatement.setInt(i + 1, iteration_id);
                    } else {
                        preparedStatement.setString(i + 1, value);
                    }
                }
                preparedStatement.addBatch();
                count++;

                if (count % BATCH_SIZE == 0 || count == records.size()) {
                    preparedStatement.executeBatch();

                    // Обновляем прогресс после обработки каждого батча
                    progressBarService.step();
                }
            }
        }
    } catch (Exception e) {
        String message = "Ошибка при вставке данных: ";
        log.error(ExceptionFilter.unwindMessages(message, e));
        description = ExceptionFilter.unwindMessages(message, e);
        throw new Exception(message + e.getMessage(), e);
    }
    progressBarService.finish();
    return true;
}
```

---

### Что изменено:
1. **`ProgressBarService` обновляется на уровне батчей**: 
   - После каждого вызова `preparedStatement.executeBatch()` вызывается `progressBarService.step()`.

2. **Размер прогресса (`totalBatchCount`)**:
   - Вычисляется на основе количества строк, делённого на размер батча:
     ```java
     int totalBatchCount = (records.size() + BATCH_SIZE - 1) / BATCH_SIZE;
     ```

3. **Транзакция всё ещё целостная**:
   - Прогресс обновляется после добавления каждого батча, но сама транзакция завершится (с `commit`) только после завершения всей обработки. Это сохраняет консистентность данных.

4. **Финальная строка завершения**:
   - После завершения всех шагов вызывается `progressBarService.finish()`, чтобы явно завершить прогрессбар.

---

### Ожидаемое поведение:
- Прогрессбар обновляется после обработки каждого батча.
- В консоль выводится одна строка, которая постепенно заполняется в реальном времени.
- Прогрессбар завершает работу только после завершения всей транзакции. 

Попробуйте внести эти изменения, и прогрессбар будет корректно работать даже при транзакционной обработке.