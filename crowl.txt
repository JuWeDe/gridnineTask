Если прогресс-бар продолжает отображаться только после завершения импорта, значит, проблема скорее всего в том, что основной поток блокируется до завершения вывода прогресса. Кроме того, отображение не 100%, а 92% указывает на неправильный расчет или недосчитанные итерации в процессе.

Давайте разберем решение более детально и исправим оба аспекта:

---

### 1. **Обновление прогресса в реальном времени**
Проблема блокировки в основном потоке возникает, если `updateProgress` вызывается слишком редко или не синхронно с текущим процессом импорта. Нужно убедиться, что:
- Прогресс-бар обновляется на каждом батче.
- Обновление в консоли происходит без задержки.

---

### Исправленный `ProgressBarService`:
Для наглядности добавим детальный расчет прогресса и упростим логику.

#### Класс `ProgressBarService`:
```java
import java.util.concurrent.atomic.AtomicInteger;

public class ProgressBarService {
    private final ProgressBar progressBar;

    public ProgressBarService(String fileName, int totalSteps) {
        this.progressBar = new ProgressBar(fileName, totalSteps);
    }

    public void updateProgress(int steps) {
        progressBar.increment(steps);
        progressBar.print();
    }

    public void complete() {
        progressBar.complete();
        progressBar.print();
        System.out.println(); // Завершаем строку.
    }

    private static class ProgressBar {
        private final String fileName;
        private final int totalSteps;
        private final AtomicInteger currentStep;

        public ProgressBar(String fileName, int totalSteps) {
            this.fileName = fileName;
            this.totalSteps = totalSteps;
            this.currentStep = new AtomicInteger(0);
        }

        public void increment(int steps) {
            currentStep.addAndGet(steps);
        }

        public void complete() {
            currentStep.set(totalSteps);
        }

        public void print() {
            int progress = Math.min((int) ((double) currentStep.get() / totalSteps * 100), 100);
            int progressBars = progress / 2; // 50 символов в баре.
            String bar = "=".repeat(progressBars) + " ".repeat(50 - progressBars);
            String progressLine = String.format("\rИмпорт файла (%s): [%s] %d%% (%d/%d)", 
                                                fileName, bar, progress, currentStep.get(), totalSteps);
            System.out.print(progressLine);
            System.out.flush();
        }
    }
}
```

---

### 2. **Как интегрировать в процесс импорта**

При обработке файла нужно обновлять прогресс-бар после обработки каждого батча.

#### Основной цикл обработки батчей:
Используйте обновление прогресса внутри цикла `for` при импорте данных.

#### Пример изменения `importCsvToDatabaseBatch`:
```java
private boolean importCsvToDatabaseBatch(Path csvFilePath, String tableName, Connection connection, char delimiter) throws Exception {
    ProgressBarService progressBarService = new ProgressBarService(csvFilePath.getFileName().toString(), totalRecords(csvFilePath));

    try (Reader reader = Files.newBufferedReader(csvFilePath);
         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withDelimiter(delimiter).withFirstRecordAsHeader())) {
        List<String> headers = csvParser.getHeaderNames().stream()
                .flatMap(header -> splitHeader(header.trim()))
                .map(header -> "\"" + header.trim() + "\"")
                .collect(Collectors.toList());
        headers.add("\"iteration_id\"");
        String insertSQL = generateInsertSQL(tableName, headers);
        int iterationId = getIterationId(csvFilePath);

        try (PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {
            List<CSVRecord> records = csvParser.getRecords();
            int count = 0;

            for (CSVRecord record : records) {
                for (int i = 0; i < headers.size(); i++) {
                    String value = (i == headers.size() - 1) 
                                   ? String.valueOf(iterationId) 
                                   : record.get(i);
                    preparedStatement.setString(i + 1, value);
                }
                preparedStatement.addBatch();
                count++;

                if (count % BATCH_SIZE == 0) {
                    preparedStatement.executeBatch();
                    progressBarService.updateProgress(BATCH_SIZE); // Обновляем прогресс после выполнения батча.
                }
            }
            preparedStatement.executeBatch();
            progressBarService.complete(); // Завершаем прогресс-бар.
        }
    } catch (Exception e) {
        String message = "importCsvToDatabaseBatch: Ошибка при batch вставке данных в бд -> ";
        log.error(ExceptionFilter.unwindMessages(message, e));
        throw new Exception(message + e.getMessage(), e);
    }
    return true;
}
```

---

### 3. **Проверка корректности расчетов**
Частичная загрузка (например, 92%) может возникать, если:
1. Общее количество строк (`totalSteps`) было рассчитано неверно.
2. Итерации обновления не совпадают с реальным количеством обработанных записей.

#### Исправим расчет `totalRecords`:
Добавим метод для подсчета общего числа строк в файле перед обработкой:

```java
private int totalRecords(Path csvFilePath) throws IOException {
    try (BufferedReader reader = Files.newBufferedReader(csvFilePath)) {
        return (int) reader.lines().skip(1).count(); // Пропускаем заголовок.
    }
}
```

Теперь `totalSteps` будет точно соответствовать количеству строк в файле.

---

### 4. **Убедитесь в правильном использовании батчей**
Убедитесь, что все данные обрабатываются корректно:
- Если последний батч меньше `BATCH_SIZE`, он тоже должен обновлять прогресс.

#### Учет последнего батча:
В методе `importCsvToDatabaseBatch` добавьте обновление прогресса после выполнения последнего батча:

```java
if (count % BATCH_SIZE != 0) {
    preparedStatement.executeBatch();
    progressBarService.updateProgress(count % BATCH_SIZE); // Обновляем прогресс для последнего батча.
}
```

---

### Итоговое поведение:
1. Прогресс-бар обновляется в реальном времени, выводя текущий статус в консоль.
2. Строка с прогресс-баром обновляется без задержек благодаря `System.out.flush()`.
3. Прогресс доходит до 100%, включая последний батч.