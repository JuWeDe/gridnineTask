Беседа № 129: 
Выбрана Ваша роль: Программист

Понял, вот решение без использования Spring Data JPA репозиториев, только с использованием чистого JDBC:

package com.example.demo.services;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.Map;

@Service
public class FolderCleaner {
    private static final Logger logger = LoggerFactory.getLogger(FolderCleaner.class);

    private final Path watchedDirectory;
    private final String jdbcUrl;
    private final String jdbcUsername;
    private final String jdbcPassword;
    private final Map<Path, LocalDateTime> fileCreationTimes;

    /**
     * Конструктор класса FolderCleaner, в который передаются необходимые параметры.
     *
     * @param directoryPath путь к директории, которую нужно очищать
     * @param jdbcUrl       URL для подключения к базе данных
     * @param jdbcUsername  username для подключения к базе данных
     * @param jdbcPassword  password для подключения к базе данных
     */
    public FolderCleaner(@Value("${app.directory-path}") String directoryPath,
                        @Value("${spring.datasource.url}") String jdbcUrl,
                        @Value("${spring.datasource.username}") String jdbcUsername,
                        @Value("${spring.datasource.password}") String jdbcPassword) {
        this.watchedDirectory = Paths.get(directoryPath);
        this.jdbcUrl = jdbcUrl;
        this.jdbcUsername = jdbcUsername;
        this.jdbcPassword = jdbcPassword;
        this.fileCreationTimes = new HashMap<>();
    }

    /**
     * Метод, выполняющийся каждые 10 минут, который удаляет файлы из папки,
     * созданные более daysCount дней назад.
     */
    @Scheduled(cron = "0 */10 * ? * *")
    public void cleanFolder() {
        try {
            Files.list(watchedDirectory)
                 .forEach(this::deleteExpiredFile);
        } catch (IOException e) {
            logger.error("Ошибка при очистке директории: {}", e.getMessage());
        }
    }

    /**
     * Метод, который проверяет, удаляет ли файл, если он старше daysCount дней.
     *
     * @param path путь к файлу
     */
    private void deleteExpiredFile(Path path) {
        int daysCount = getExpireDaysForFile(path.getFileName().toString());

        if (daysCount > 0) {
            LocalDateTime creationTime = fileCreationTimes.getOrDefault(path, LocalDateTime.now().minusDays(daysCount + 1));
            long daysSinceCreation = ChronoUnit.DAYS.between(creationTime, LocalDateTime.now());

            if (daysSinceCreation > daysCount) {
                try {
                    Files.delete(path);
                    logger.info("Удален файл {}", path.getFileName());
                    fileCreationTimes.remove(path);
                } catch (IOException e) {
                    logger.error("Ошибка при удалении файла {}: {}", path.getFileName(), e.getMessage());
                }
            }
        }
    }

    /**
     * Метод, который получает количество дней, через которое файл должен быть удален,
     * на основе информации из таблицы file_iterations.
     *
     * @param fileName имя файла
     * @return количество дней, после которых файл будет удален
     */

    private int getExpireDaysForFile(String fileName) {
        try (Connection connection = DriverManager.getConnection(jdbcUrl, jdbcUsername, jdbcPassword);
             PreparedStatement statement = connection.prepareStatement(
                     "SELECT fi.days_to_expire " +
                     "FROM file_iterations fi " +
                     "WHERE fi.file_name = ?")) {
            statement.setString(1, fileName);
            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    return resultSet.getInt("days_to_expire");
                }
            }
        } catch (SQLException e) {
            logger.error("Ошибка при получении daysToExpire: {}", e.getMessage());
        }
        return 0;
    }
}

В этом решении:

1. Параметры для подключения к базе данных (jdbcUrl, jdbcUsername, jdbcPassword) внедряются в конструктор с помощью @Value.
2. Метод getExpireDaysForFile() использует чистый JDBC для выполнения запроса к базе данных и получения значения days_to_expire для заданного имени файла.
3. Метод deleteExpiredFile() использует результат, возвращаемый getExpireDaysForFile(), для проверки и удаления файлов.

Убедитесь, что в файле application.properties или application.yml вы указали правильные значения для Spring Data источника данных:

spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.username=sa
spring.datasource.password=password

Это решение не использует Spring Data JPA репозитории, а напрямую работает с JDBC для получения значения days_to_expire из базы данных.

5537 из 16384