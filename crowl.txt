package com.example.demo.service;

import com.example.demo.entities.FileIteration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class FileIterationCacheService {

    private static final Logger logger = LoggerFactory.getLogger(FileIterationCacheService.class);

    private final DataSource dataSource;
    private final ConcurrentHashMap<Integer, FileIteration> cache = new ConcurrentHashMap<>();

    public FileIterationCacheService(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @PostConstruct
    public void initializeCache() {
        logger.info("Начало кэширования данных из таблицы file_iterations...");

        try (Connection connection = dataSource.getConnection();
             PreparedStatement statement = connection.prepareStatement("SELECT * FROM file_iterations");
             ResultSet resultSet = statement.executeQuery()) {

            List<FileIteration> iterations = new ArrayList<>();
            while (resultSet.next()) {
                FileIteration fileIteration = new FileIteration();
                fileIteration.setId(resultSet.getInt("id"));
                fileIteration.setCategoryId(resultSet.getInt("category_id"));
                fileIteration.setName(resultSet.getString("name"));
                fileIteration.setArrivedAt(resultSet.getTimestamp("arrived_at"));
                fileIteration.setDestination(resultSet.getString("destination"));
                fileIteration.setState(resultSet.getString("state"));
                fileIteration.setFileSize(resultSet.getLong("file_size"));
                fileIteration.setArchiveSize(resultSet.getLong("archive_size"));
                fileIteration.setArchiveName(resultSet.getString("archive_name"));
                fileIteration.setProcessingStart(resultSet.getTimestamp("processing_start"));
                fileIteration.setProcessingEnd(resultSet.getTimestamp("processing_end"));
                fileIteration.setRows(resultSet.getInt("rows"));

                // Кэшируем данные с ключом, основанным на ID итерации
                cache.put(fileIteration.getId(), fileIteration);
                iterations.add(fileIteration);
            }

            logger.info("Кэширование завершено. Всего итераций закэшировано: {}", iterations.size());

        } catch (Exception e) {
            logger.error("Ошибка при кэшировании данных: ", e);
        }
    }

    // Получение итерации по ID из кэша
    public FileIteration getIterationById(int id) {
        return cache.get(id);
    }

    // Получение всех закэшированных итераций
    public List<FileIteration> getAllIterations() {
        return new ArrayList<>(cache.values());
    }

    // Метод для ручной очистки кэша (при необходимости)
    public void clearCache() {
        cache.clear();
        logger.info("Кэш file_iterations очищен.");
    }
}
