Беседа № 120: 
Выбрана Ваша роль: Программист

Хорошо, вот как вы можете настроить Logback в вашем Gradle-проекте Spring Boot 2.2.4:

1. Добавьте следующие зависимости в ваш build.gradle:

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-log4j2'
}

2. Создайте файл logback.xml в src/main/resources со следующим содержимым:

<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <maxFileSize>10MB</maxFileSize>
            <totalSizeCap>100MB</totalSizeCap>
            <maxHistory>10</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>
</configuration>

3. Создайте ваш UltimateLogSpammer класс, как в предыдущем ответе:

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
public class UltimateLogSpammer {
    private static final Logger log = LoggerFactory.getLogger(UltimateLogSpammer.class);
    private static final long MAX_LOG_FILE_SIZE = 10 * 1024 * 1024; // 10 MB
    private static final long MAX_TOTAL_LOG_SIZE = 100 * 1024 * 1024; // 100 MB
    private static final int MAX_LOG_FILES = 10;
    private static final DateTimeFormatter DATETIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    @Scheduled(fixedRate = 60000) // Выполняется каждую минуту
    public void spamLogs() {
        StringBuilder logMessage = new StringBuilder();
        logMessage.append("Timestamp: ").append(LocalDateTime.now().format(DATETIME_FORMATTER)).append("\n");

        // Создание записи лога размером 1 MB
        for (int i = 0; i < 100_000; i++) {
            logMessage.append("This is a very long log message. This is a very long log message. This is a very long log message. This is a very long log message. This is a very long log message.");
        }

        log.info(logMessage.toString());
        cleanupLogs();
    }

    private void cleanupLogs() {
        Path logsDir = Paths.get("logs");
        if (!Files.exists(logsDir)) {
            Files.createDirectory(logsDir);
        }

        long totalLogSize = 0;
        int logFileCount = 0;
        for (File file : logsDir.toFile().listFiles()) {
            totalLogSize += file.length();
            logFileCount++;
        }

        if (totalLogSize > MAX_TOTAL_LOG_SIZE || logFileCount > MAX_LOG_FILES) {
            for (File file : logsDir.toFile().listFiles()) {
                file.delete();
            }
        }
    }
}