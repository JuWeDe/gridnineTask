
/**
 * Метод для создания таблицы на основе заголовков CSV
 * @param csvFilePath - путь до файла
 * @param tableName - имя таблицы
 * @param connection - соединение с бд
 * @param delimiter - разделитель csv файла
 */
private void createTableFromCsv(Path csvFilePath, String tableName, Connection connection, char delimiter) throws IOException, SQLException {
    try (Reader reader = Files.newBufferedReader(csvFilePath);
         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withDelimiter(delimiter).withFirstRecordAsHeader())) {

        List<String> headers = csvParser.getHeaderNames().stream()
                .map(header -> fixHeader(header.trim()))  // Исправляем заголовки
                .collect(Collectors.toList());

        String columns = headers.stream()
                .map(header -> "\"" + header + "\" TEXT")
                .collect(Collectors.joining(", "));

        String createTableSQL = String.format("CREATE TABLE IF NOT EXISTS %s (%s)", tableName, columns);
        try (Statement statement = connection.createStatement()) {
            statement.execute(createTableSQL);
        }
    }
}

/**
 * Метод для исправления заголовков, содержащих пробелы
 * @param header - исходный заголовок столбца
 * @return исправленный заголовок
 */
private String fixHeader(String header) {
    // Если заголовок содержит пробелы, разбиваем его на несколько частей
    if (header.contains(" ")) {
        // Если нужно, мы можем добавить дополнительную обработку, например объединение слов через нижнее подчеркивание
        return header.replaceAll("\\s+", "_");  // Пробелы заменяем на нижнее подчеркивание
    }
    return header;
}


private void importCsvToDatabaseBatch(Path csvFilePath, String tableName, Connection connection, char delimiter) throws IOException, SQLException {
    try (Reader reader = Files.newBufferedReader(csvFilePath);
         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withDelimiter(delimiter).withFirstRecordAsHeader())) {
        List<String> headers = csvParser.getHeaderNames().stream()
                .map(header -> "\"" + header.trim() + "\"")  // Поддерживаем имена столбцов с #
                .collect(Collectors.toList());

        // Проверяем на наличие объединенных столбцов
        headers = fixMergedHeaders(headers);

        String insertSQL = generateInsertSQL(tableName, headers);

        try (PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {
            List<CSVRecord> records = csvParser.getRecords();
            int count = 0;

            for (CSVRecord record : records) {
                // Проверяем на наличие объединенных данных в строках
                List<String> values = fixMergedValues(record, headers.size());

                for (int i = 0; i < headers.size(); i++) {
                    String value = values.get(i);
                    if (value == null || value.trim().isEmpty()) {
                        preparedStatement.setNull(i + 1, java.sql.Types.NULL);
                    } else {
                        preparedStatement.setString(i + 1, value);
                    }
                }
                preparedStatement.addBatch();
                count++;

                if (count % BATCHSIZE == 0) {
                    preparedStatement.executeBatch();
                }
            }

            preparedStatement.executeBatch();
        }
    }
}

/**
 * Функция для исправления объединенных заголовков
 * @param headers Заголовки, которые нужно проверить
 * @return Исправленные заголовки
 */
private List<String> fixMergedHeaders(List<String> headers) {
    List<String> fixedHeaders = new ArrayList<>();
    for (String header : headers) {
        // Разделяем заголовок, если в нем есть пробел
        if (header.contains(" ")) {
            String[] splitHeaders = header.split("\\s+");
            for (String splitHeader : splitHeaders) {
                fixedHeaders.add("\"" + splitHeader.trim() + "\"");
            }
        } else {
            fixedHeaders.add(header);
        }
    }
    return fixedHeaders;
}

/**
 * Функция для исправления объединенных данных в строках
 * @param record Строка с данными
 * @param expectedSize Ожидаемое количество столбцов
 * @return Исправленные значения
 */
private List<String> fixMergedValues(CSVRecord record, int expectedSize) {
    List<String> values = new ArrayList<>();
    
    for (String value : record) {
        // Добавляем значение с учетом его корректного разделения
        values.addAll(Arrays.asList(value.split("\\s+")));
    }
    
    // Если количество значений отличается от ожидаемого, добавляем недостающие пустые значения
    while (values.size() < expectedSize) {
        values.add(null);
    }
    
    return values;
}
