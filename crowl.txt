private void processCsvFile(Path csvFilePath) {
    String fileName = csvFilePath.getFileName().toString();
    String tableName = getTableNameWithoutExtension(fileName);
    boolean isTableCreated = false;
    Connection connection = null;
    Path errorDirPath = Paths.get(errorDir);

    // Проверка, что файл был загружен полностью
    if (isFileFullyUploaded(csvFilePath, 5, 2000)) {
        logger.error("Файл {} не был загружен полностью", csvFilePath.getFileName());
        moveFile(csvFilePath, errorDirPath);
        updateFileIterations(csvFilePath.getFileName(), "error", errorDir, "Файл не был загружен полностью", new Timestamp(System.currentTimeMillis()));
        return;
    }

    try {
        connection = getConnectionBasedOnFileName(fileName);
        if (connection != null) {
            connection.setAutoCommit(false);  // Отключаем автокоммит для управления транзакцией вручную
        }

        char delimiter = detectDelimiter(csvFilePath);

        // Проверка существования таблицы
        if (!doesTableExist(connection, tableName)) {
            createTableFromCsv(csvFilePath, tableName, connection, delimiter);
            isTableCreated = true;
        }

        // Импорт данных из CSV в таблицу
        importCsvToDatabaseBatch(csvFilePath, tableName, connection, delimiter);

        if (connection != null) {
            connection.commit();  // Коммит транзакции, если импорт прошел успешно
        }
        
        // Логирование успеха и перемещение файла
        updateFileIterations(csvFilePath.getFileName(), "success", successDir, "", new Timestamp(System.currentTimeMillis()));
        logger.info("Файл {} успешно обработан", fileName);
        moveFile(csvFilePath, Paths.get(successDir));
        processedFiles.remove(fileName);
    } catch (DataIntegrityException e) {
        // Обрабатываем ошибку с пропущенными значениями
        logger.warn("Ошибка целостности данных при обработке файла {}: {}", fileName, e.getMessage());
        try {
            if (connection != null) {
                connection.rollback();  // Откат изменений при обнаружении пропуска данных
                logger.info("Откат изменений для таблицы {}", tableName);

                if (isTableCreated) {
                    // Удаление таблицы, если она была создана в процессе текущего импорта
                    dropTableIfExists(connection, tableName);
                }
            }
        } catch (SQLException rollbackEx) {
            logger.error("Ошибка при откате изменений для таблицы {}: {}", tableName, ExceptionFilter.displayError(rollbackEx));
        }

        // Логирование ошибки и перемещение файла в папку ошибок
        updateFileIterations(csvFilePath.getFileName(), "error", errorDir, "Пропуск данных в файле", new Timestamp(System.currentTimeMillis()));
        moveFile(csvFilePath, errorDirPath);
        processedFiles.remove(fileName);
    } catch (Exception e) {
        // Обрабатываем другие ошибки
        logger.error("Ошибка при импортировании файла {} в БД: {}", fileName, ExceptionFilter.displayError(e));
        try {
            if (connection != null) {
                connection.rollback();  // Откат изменений при общей ошибке
                logger.info("Откат изменений для таблицы {}", tableName);

                if (isTableCreated) {
                    dropTableIfExists(connection, tableName);
                }
            }
        } catch (SQLException rollbackEx) {
            logger.error("Ошибка при откате изменений для таблицы {}: {}", tableName, ExceptionFilter.displayError(rollbackEx));
        }

        // Логирование ошибки и перемещение файла в папку ошибок
        updateFileIterations(csvFilePath.getFileName(), "error", errorDir, "Ошибка обработки файла", new Timestamp(System.currentTimeMillis()));
        moveFile(csvFilePath, errorDirPath);
        processedFiles.remove(fileName);
    } finally {
        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {
                logger.error("Ошибка при закрытии соединения: {}", ExceptionFilter.displayError(e));
            }
        }
    }
}



private void importCsvToDatabaseBatch(Path csvFilePath, String tableName, Connection connection, char delimiter) throws IOException, SQLException {
    try (Reader reader = Files.newBufferedReader(csvFilePath);
         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withDelimiter(delimiter).withFirstRecordAsHeader())) {

        List<String> headers = csvParser.getHeaderNames().stream()
                .flatMap(header -> splitHeader(header.trim()))  // Разделяем заголовки по пробелам
                .map(header -> "\"" + header.trim() + "\"") // Поддерживаем имена столбцов с #
                .collect(Collectors.toList());

        String insertSQL = generateInsertSQL(tableName, headers);

        try (PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {
            List<CSVRecord> records = csvParser.getRecords();
            int count = 0;

            for (CSVRecord record : records) {
                for (int i = 0; i < headers.size(); i++) {
                    String value = record.get(i);
                    if (value == null || value.trim().isEmpty()) {
                        // Логируем информацию о проблемной строке и выбрасываем исключение
                        logger.warn("Пропуск данных в строке {} в файле {}: {}", record.getRecordNumber(), csvFilePath.getFileName(), record);
                        
                        // Прекращаем импорт и выбрасываем специальное исключение
                        throw new DataIntegrityException("Обнаружен пропуск данных в строке " + record.getRecordNumber());
                    } else {
                        preparedStatement.setString(i + 1, value);
                    }
                }

                preparedStatement.addBatch();
                count++;

                if (count % BATCH_SIZE == 0) {
                    preparedStatement.executeBatch();
                }
            }

            preparedStatement.executeBatch();
        }
    }
}
