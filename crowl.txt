Чтобы интегрировать возможность выбора разных реализаций прогресс-баров через REST API и сделать код более гибким, давайте реализуем следующую архитектуру:

1. **Создаем интерфейс `ProgressBarInterface`** — это позволит абстрагироваться от конкретной реализации.
2. **Реализуем несколько вариантов прогресс-баров: ваш текущий, `TongfeiProgressBarService`, и любую другую уникальную реализацию.**
3. **Добавим `ProgressBarManager` для динамического управления реализациями.**
4. **Внедрим REST-контроллер для выбора прогресс-бара во время выполнения.**
5. **Интегрируем это в метод импорта `importCsvToDatabaseBatch`.**

---

### Полный код:

---

### 1. **Интерфейс ProgressBarInterface**

```java
public interface ProgressBarInterface {
    void startProgress(String fileName, long totalRecords, int batchSize);
    void updateProgress(String fileName, int stepsCompleted);
    void completeProgress(String fileName);
}
```

---

### 2. **SimpleProgressBarService (ваш текущий прогресс-бар)**

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Service("simpleProgressBar")
public class SimpleProgressBarService implements ProgressBarInterface {

    private final Map<String, ProgressBar> progressBars = new ConcurrentHashMap<>();

    @Override
    public void startProgress(String fileName, long totalRecords, int batchSize) {
        int totalSteps = (int) Math.ceil((double) totalRecords / batchSize);
        progressBars.put(fileName, new ProgressBar(totalSteps, fileName));
    }

    @Override
    public void updateProgress(String fileName, int stepsCompleted) {
        ProgressBar progressBar = progressBars.get(fileName);
        if (progressBar != null) {
            progressBar.update(stepsCompleted);
        }
    }

    @Override
    public void completeProgress(String fileName) {
        ProgressBar progressBar = progressBars.get(fileName);
        if (progressBar != null) {
            progressBar.complete();
        }
        progressBars.remove(fileName);
    }

    private static class ProgressBar {
        private final int totalSteps;
        private final String fileName;
        private int completedSteps;
        private int lastLoggedPercentage = -1;

        public ProgressBar(int totalSteps, String fileName) {
            this.totalSteps = totalSteps;
            this.fileName = fileName;
            this.completedSteps = 0;
        }

        public synchronized void update(int steps) {
            completedSteps = Math.min(completedSteps + steps, totalSteps);
            printProgress();
        }

        public synchronized void complete() {
            completedSteps = totalSteps;
            printProgress();
        }

        private void printProgress() {
            int percentage = (int) ((double) completedSteps / totalSteps * 100);
            if (percentage != lastLoggedPercentage) {
                lastLoggedPercentage = percentage;
                log.info("Прогресс импорта файла {}: {}%", fileName, percentage);
            }
        }
    }
}
```

---

### 3. **TongfeiProgressBarService**

```java
import me.tongfei.progressbar.ProgressBar;
import me.tongfei.progressbar.ProgressBarBuilder;
import me.tongfei.progressbar.ProgressBarStyle;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service("tongfeiProgressBar")
public class TongfeiProgressBarService implements ProgressBarInterface {

    private final Map<String, ProgressBar> progressBars = new ConcurrentHashMap<>();

    @Override
    public void startProgress(String fileName, long totalRecords, int batchSize) {
        int totalSteps = (int) Math.ceil((double) totalRecords / batchSize);
        ProgressBar progressBar = new ProgressBarBuilder()
                .setTaskName("Импорт " + fileName)
                .setStyle(ProgressBarStyle.ASCII)
                .setInitialMax(totalSteps)
                .build();
        progressBars.put(fileName, progressBar);
    }

    @Override
    public void updateProgress(String fileName, int stepsCompleted) {
        ProgressBar progressBar = progressBars.get(fileName);
        if (progressBar != null) {
            progressBar.stepTo(stepsCompleted);
        }
    }

    @Override
    public void completeProgress(String fileName) {
        ProgressBar progressBar = progressBars.get(fileName);
        if (progressBar != null) {
            progressBar.stepTo(progressBar.getMax());
            progressBar.close();
        }
        progressBars.remove(fileName);
    }
}
```

---

### 4. **DotsProgressBarService (альтернативная реализация)**

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Slf4j
@Service("dotsProgressBar")
public class DotsProgressBarService implements ProgressBarInterface {

    private final Map<String, Integer> progressBars = new ConcurrentHashMap<>();

    @Override
    public void startProgress(String fileName, long totalRecords, int batchSize) {
        progressBars.put(fileName, 0);
    }

    @Override
    public void updateProgress(String fileName, int stepsCompleted) {
        int progress = progressBars.getOrDefault(fileName, 0) + stepsCompleted;
        progressBars.put(fileName, progress);
        StringBuilder dots = new StringBuilder();
        for (int i = 0; i < progress % 10; i++) {
            dots.append(".");
        }
        log.info("Импорт файла {}: {}", fileName, dots);
    }

    @Override
    public void completeProgress(String fileName) {
        log.info("Импорт файла {} завершён.", fileName);
        progressBars.remove(fileName);
    }
}
```

---

### 5. **ProgressBarManager**

```java
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class ProgressBarManager {

    private ProgressBarInterface progressBarImplementation;

    public ProgressBarManager(@Qualifier("simpleProgressBar") ProgressBarInterface progressBarImplementation) {
        this.progressBarImplementation = progressBarImplementation;
    }

    public void setProgressBarImplementation(ProgressBarInterface progressBarImplementation) {
        this.progressBarImplementation = progressBarImplementation;
    }

    public ProgressBarInterface getProgressBarImplementation() {
        return progressBarImplementation;
    }
}
```

---

### 6. **REST Контроллер**

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/progress-bar")
public class ProgressBarController {

    @Autowired
    private ProgressBarManager progressBarManager;

    @PostMapping("/set")
    public String setProgressBarImplementation(@RequestParam String implementation) {
        switch (implementation.toLowerCase()) {
            case "simple":
                progressBarManager.setProgressBarImplementation(new SimpleProgressBarService());
                break;
            case "tongfei":
                progressBarManager.setProgressBarImplementation(new TongfeiProgressBarService());
                break;
            case "dots":
                progressBarManager.setProgressBarImplementation(new DotsProgressBarService());
                break;
            default:
                return "Invalid implementation. Choose: simple, tongfei, dots.";
        }
        return "Implementation set to " + implementation;
    }

    @GetMapping("/current")
    public String getCurrentImplementation() {
        return "Current implementation: " + progressBarManager.getProgressBarImplementation().getClass().getSimpleName();
    }
}
```

---

### 7. **Интеграция с importCsvToDatabaseBatch**

```java
@Autowired
private ProgressBarManager progressBarManager;

private boolean importCsvToDatabaseBatch(Path csvFilePath, String tableName, Connection connection, char delimiter) throws Exception {
    ProgressBarInterface progressBar = progressBarManager.getProgressBarImplementation();

    long totalRecords = fileIteration.getRows();
    progressBar.startProgress(csvFilePath.getFileName().toString(), totalRecords, BATCH_SIZE);

    try (Reader reader = Files.newBufferedReader(csvFilePath);
         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withDelimiter(delimiter).withFirstRecordAsHeader())) {
        int count = 0;

        for (CSVRecord record : csvParser.getRecords()) {
            // Обработка записей

            count++;
            if (count % BATCH_SIZE == 0) {
                progressBar.updateProgress(csvFilePath.getFileName().toString(), 1);
            }
        }
        progressBar.completeProgress(csvFilePath.getFileName().toString());
    }
    return true;
}
```

---

### Пояснения:
1. **Интерфейс `ProgressBarInterface`** позволяет легко добавлять новые реализации.
2. REST API позволяет переключаться между реализациями на лету.
3. Все реализации независимы и могут быть легко расширены или модифицированы.
4. Прогресс-бар корректно интегрирован в метод импорта.