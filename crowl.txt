
Для добавления ProgressBar в данный код можно использовать отдельный сервис, который будет отслеживать состояние обработки файлов. ProgressBar будет обновляться по мере обработки батчей данных при импорте файла. Вот пример, как можно интегрировать ProgressBar:

1. **Создайте класс `ProgressBarService`**, который будет отслеживать состояние обработки:

```java
@Service
@Slf4j
public class ProgressBarService {
    private final Map<String, ProgressBar> progressBars = new ConcurrentHashMap<>();

    public void startProgress(String fileName, int totalSteps) {
        progressBars.put(fileName, new ProgressBar(totalSteps));
        log.info("Начало прогресса для файла {} с {} шагами", fileName, totalSteps);
    }

    public void updateProgress(String fileName, int stepsCompleted) {
        ProgressBar progressBar = progressBars.get(fileName);
        if (progressBar != null) {
            progressBar.update(stepsCompleted);
            log.info("Прогресс для файла {}: {}%", fileName, progressBar.getPercentage());
        }
    }

    public void completeProgress(String fileName) {
        ProgressBar progressBar = progressBars.remove(fileName);
        if (progressBar != null) {
            progressBar.complete();
            log.info("Прогресс для файла {} завершён.", fileName);
        }
    }

    @Slf4j
    private static class ProgressBar {
        private final int totalSteps;
        private int completedSteps;

        public ProgressBar(int totalSteps) {
            this.totalSteps = totalSteps;
            this.completedSteps = 0;
        }

        public synchronized void update(int steps) {
            this.completedSteps = Math.min(this.completedSteps + steps, totalSteps);
        }

        public synchronized int getPercentage() {
            return (int) ((double) completedSteps / totalSteps * 100);
        }

        public synchronized void complete() {
            this.completedSteps = totalSteps;
        }
    }
}
```

2. **Интеграция с `FileImporterService`:** Внедрите `ProgressBarService` в `FileImporterService` и обновляйте прогресс на разных этапах обработки файла.

Пример изменения метода `importCsvToDatabaseBatch`:

```java
private boolean importCsvToDatabaseBatch(Path csvFilePath, String tableName, Connection connection, char delimiter) throws Exception {
    int totalRecords = countLines(csvFilePath) - 1; // Вычисляем количество записей, вычитая строку заголовка
    progressBarService.startProgress(csvFilePath.getFileName().toString(), totalRecords);

    try (Reader reader = Files.newBufferedReader(csvFilePath);
         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withDelimiter(delimiter).withFirstRecordAsHeader())) {
        List<String> headers = csvParser.getHeaderNames().stream()
                .flatMap(header -> splitHeader(header.trim()))
                .map(header -> "\"" + header.trim() + "\"")
                .collect(Collectors.toList());
        headers.add("\"iteration_id\"");
        String insertSQL = generateInsertSQL(tableName, headers);
        int iteration_id = getIterationId(csvFilePath);

        try (PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {
            List<CSVRecord> records = csvParser.getRecords();
            int count = 0;
            for (CSVRecord record : records) {
                for (int i = 0; i < headers.size(); i++) {
                    String value = i == headers.size() - 1 ? String.valueOf(iteration_id) : record.get(i);
                    if (!getIgnoreGaps().equals("active") && (value == null || value.trim().isEmpty())) {
                        description = "Пропуск данных";
                        return false;
                    } else {
                        if (i == headers.size() - 1) {
                            preparedStatement.setInt(i + 1, iteration_id);
                        } else {
                            preparedStatement.setString(i + 1, value);
                        }
                    }
                }
                preparedStatement.addBatch();
                count++;

                if (count % BATCH_SIZE == 0) {
                    preparedStatement.executeBatch();
                    progressBarService.updateProgress(csvFilePath.getFileName().toString(), BATCH_SIZE);
                }
            }
            preparedStatement.executeBatch();
            progressBarService.updateProgress(csvFilePath.getFileName().toString(), count % BATCH_SIZE);
        }
    } catch (Exception e) {
        String message = "importCsvToDatabaseBatch: Ошибка при batch вставке данных в бд -> ";
        log.error(ExceptionFilter.unwindMessages(message, e));
        description = ExceptionFilter.unwindMessages(message, e);
        throw new Exception(message + e.getMessage(), e);
    } finally {
        progressBarService.completeProgress(csvFilePath.getFileName().toString());
    }
    return true;
}
```

3. **Изменения в других методах:** Аналогично обновляйте прогресс при обработке ZIP-файлов или других типов данных. Например, для ZIP-файла создайте общий прогресс и обновляйте его при обработке каждого файла внутри архива.

4. **Логирование прогресса:** Теперь `ProgressBarService` будет выводить процент выполнения задачи в логах. Это полезно для мониторинга.

Этот подход позволяет гибко управлять состоянием прогресса для каждого файла и отображать шаги, такие как обработка батчей данных.