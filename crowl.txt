Если размер прогресса должен быть рассчитан на основе размера **BATCH_SIZE**, нужно корректно рассчитать количество шагов прогресса, основываясь на общем количестве строк в файле и размере батча. Вот как это можно реализовать:

### Изменение `ProgressBarService`
Обновим логику для использования размера батча:

```java
public void startProgress(String fileName, int totalRecords, int batchSize) {
    int totalSteps = (int) Math.ceil((double) totalRecords / batchSize); // Количество шагов равно количеству батчей
    progressBars.put(fileName, new ProgressBar(totalSteps));
    log.info("Начало прогресса для файла {} с {} шагами (размер батча: {})", fileName, totalSteps, batchSize);
}
```

### Изменение метода `importCsvToDatabaseBatch`
Теперь прогресс будет отслеживаться на уровне батчей, а не строк:

```java
private boolean importCsvToDatabaseBatch(Path csvFilePath, String tableName, Connection connection, char delimiter) throws Exception {
    int totalRecords = countLines(csvFilePath) - 1; // Общее количество строк без заголовка
    progressBarService.startProgress(csvFilePath.getFileName().toString(), totalRecords, BATCH_SIZE);

    try (Reader reader = Files.newBufferedReader(csvFilePath);
         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withDelimiter(delimiter).withFirstRecordAsHeader())) {
        List<String> headers = csvParser.getHeaderNames().stream()
                .flatMap(header -> splitHeader(header.trim()))
                .map(header -> "\"" + header.trim() + "\"")
                .collect(Collectors.toList());
        headers.add("\"iteration_id\"");
        String insertSQL = generateInsertSQL(tableName, headers);
        int iteration_id = getIterationId(csvFilePath);

        try (PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {
            List<CSVRecord> records = csvParser.getRecords();
            int count = 0;
            int stepsCompleted = 0;

            for (CSVRecord record : records) {
                for (int i = 0; i < headers.size(); i++) {
                    String value = i == headers.size() - 1 ? String.valueOf(iteration_id) : record.get(i);
                    if (!getIgnoreGaps().equals("active") && (value == null || value.trim().isEmpty())) {
                        description = "Пропуск данных";
                        return false;
                    } else {
                        if (i == headers.size() - 1) {
                            preparedStatement.setInt(i + 1, iteration_id);
                        } else {
                            preparedStatement.setString(i + 1, value);
                        }
                    }
                }
                preparedStatement.addBatch();
                count++;

                if (count % BATCH_SIZE == 0) {
                    preparedStatement.executeBatch();
                    stepsCompleted++;
                    progressBarService.updateProgress(csvFilePath.getFileName().toString(), 1); // Обновляем на 1 шаг (1 батч)
                }
            }
            preparedStatement.executeBatch(); // Выполняем оставшиеся записи
            if (count % BATCH_SIZE != 0) {
                stepsCompleted++;
                progressBarService.updateProgress(csvFilePath.getFileName().toString(), 1); // Обновляем для последнего батча
            }
        }
    } catch (Exception e) {
        String message = "importCsvToDatabaseBatch: Ошибка при batch вставке данных в бд -> ";
        log.error(ExceptionFilter.unwindMessages(message, e));
        description = ExceptionFilter.unwindMessages(message, e);
        throw new Exception(message + e.getMessage(), e);
    } finally {
        progressBarService.completeProgress(csvFilePath.getFileName().toString());
    }
    return true;
}
```

### Подсчет строк файла
Для подсчета строк в файле используем метод `countLines`:

```java
private int countLines(Path filePath) throws IOException {
    try (Stream<String> lines = Files.lines(filePath)) {
        return (int) lines.count();
    }
}
```

### Итоговая логика
1. **Прогресс бар** создается с количеством шагов, равным `totalRecords / BATCH_SIZE`.
2. На каждом выполнении батча прогресс обновляется на 1 шаг.
3. Последний шаг обновляется, если общее количество строк не делится нацело на размер батча.
4. Логирование происходит в формате, отражающем состояние прогресса в процентах.

### Пример работы
Если у вас файл с 20 млн строк и размер батча равен 10 000:
- Общее количество шагов: \( \frac{20\ 000\ 000}{10\ 000} = 2\ 000 \).
- Прогресс бар будет обновляться каждые 10 000 строк.