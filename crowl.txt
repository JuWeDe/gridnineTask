private void processCsvFile(Path csvFilePath, boolean shouldMove) {
    try {
        // Логика обработки CSV файла
        // ...

        if (shouldMove) {
            moveFile(csvFilePath, Paths.get(successDir));  // Перемещаем только если флаг установлен
        }
    } catch (Exception ex) {
        logger.error("Ошибка обработки CSV файла {}: {}", csvFilePath, ex.getMessage());
        throw ex;  // Пробрасываем ошибку обратно
    }
}


processZipFile


private void processZipFile(Path zipFilePath) {
    String zipFileName = zipFilePath.getFileName().toString();
    boolean success = true;

    // Проверяем, загружен ли файл полностью
    if (!isFileFullyUploaded(zipFilePath, 5, 2000)) {
        logger.error("Файл {} не загружен", zipFileName);
        moveFile(zipFilePath, Paths.get(errorDir));
        updateFileIterations(zipFilePath.getFileName(), "error", errorDir, new Timestamp(System.currentTimeMillis()));
        return;
    }

    // Создаем временную папку
    Path tempDir;
    try {
        tempDir = Files.createTempDirectory("zip_extract_");
    } catch (IOException e) {
        logger.error("Не удалось создать временную папку: {}", ExceptionFilter.displayError(e));
        moveFile(zipFilePath, Paths.get(errorDir));
        return;
    }

    List<Path> extractedFiles = new ArrayList<>(); // Для хранения путей извлеченных файлов

    try (ZipInputStream zis = new ZipInputStream(Files.newInputStream(zipFilePath))) {
        ZipEntry zipEntry;
        while ((zipEntry = zis.getNextEntry()) != null) {
            if (zipEntry.getName().endsWith(".csv")) {
                // Извлекаем файл во временную директорию
                Path extractedFile = tempDir.resolve(zipEntry.getName());
                Files.createDirectories(extractedFile.getParent());  // Создаем директории, если не существуют
                Files.copy(zis, extractedFile, StandardCopyOption.REPLACE_EXISTING);
                extractedFiles.add(extractedFile);  // Добавляем файл в список извлеченных

                // Обрабатываем CSV файл
                try {
                    processCsvFile(extractedFile, false);  // Передаем флаг false, чтобы не перемещать CSV файлы
                } catch (Exception ex) {
                    logger.error("Ошибка при обработке CSV файла {}: {}", extractedFile, ex.getMessage());
                    success = false;  // Устанавливаем флаг ошибки
                    break;  // Прерываем обработку при первой ошибке
                }
            }
        }

        // Если все файлы успешно обработаны
        if (success) {
            // Перемещаем ZIP файл в директорию успешной обработки (перемещаем только архив)
            moveFile(zipFilePath, Paths.get(successDir));
        } else {
            // При ошибке перемещаем архив в директорию с ошибками
            moveFile(zipFilePath, Paths.get(errorDir));
        }

    } catch (IOException e) {
        logger.error("Ошибка при распаковке архива {}: {}", zipFileName, ExceptionFilter.displayError(e));
        success = false;
    } finally {
        // Очищаем временную папку
        try {
            Files.walk(tempDir)
                .sorted(Comparator.reverseOrder())
                .map(Path::toFile)
                .forEach(file -> {
                    if (!file.delete()) {
                        logger.error("Не удалось удалить файл: {}", file.getPath());
                    }
                });
            Files.delete(tempDir);  // Удаляем саму временную директорию
        } catch (IOException e) {
            logger.error("Ошибка при очистке временной папки {}: {}", tempDir, ExceptionFilter.displayError(e));
        }
    }

    // В случае ошибки или если распаковка прошла неуспешно
    if (!success) {
        logger.error("Неудачная обработка архива: {}", zipFileName);
        moveFile(zipFilePath, Paths.get(errorDir));
    }
}

