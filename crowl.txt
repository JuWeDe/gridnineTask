Беседа № 126: 
Выбрана Ваша роль: Программист

Да, можно использовать WatchService без бесконечного цикла while(true). Вот пример обновленного класса FolderCleaner:

import java.io.IOException;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class FolderCleaner {
    private final Path watchedDirectory;
    private final ScheduledExecutorService scheduledExecutorService;
    private final Map<Path, LocalDateTime> fileCreationTimes;
    private final int expirationSeconds;
    private final WatchService watchService;
    private final WatchKey watchKey;

    public FolderCleaner(String directoryPath, int expirationSeconds) throws IOException {
        this.watchedDirectory = Paths.get(directoryPath);
        this.expirationSeconds = expirationSeconds;
        this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();
        this.fileCreationTimes = new HashMap<>();

        // Регистрируем наблюдение за директорией
        this.watchService = FileSystems.getDefault().newWatchService();
        this.watchKey = watchedDirectory.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,
                StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);
    }

    public void start() {
        new Thread(() -> {
            while (true) {
                // Ожидание изменений в директории
                WatchKey key;
                try {
                    key = watchService.take();
                } catch (InterruptedException e) {
                    return;
                }

                // Обработка изменений
                for (WatchEvent<?> event : key.pollEvents()) {
                    WatchEvent.Kind<?> kind = event.kind();
                    Path path = watchedDirectory.resolve((Path) event.context());

                    if (kind == StandardWatchEventKinds.ENTRY_CREATE) {
                        // Новый файл создан
                        fileCreationTimes.put(path, LocalDateTime.now());
                        System.out.println("New file added: " + path.getFileName());
                        scheduleFileExpiration(path);
                    } else if (kind == StandardWatchEventKinds.ENTRY_DELETE) {
                        // Файл удален
                        fileCreationTimes.remove(path);
                    } else if (kind == StandardWatchEventKinds.ENTRY_MODIFY) {
                        // Файл изменен
                        // Можно реализовать какие-либо действия, например, обновить метку времени
                    } else if (kind == StandardWatchEventKinds.OVERFLOW) {
                        // Пропущено событие, ничего не делаем
                    }
                }

                // Сбрасываем ключ для дальнейшего использования
                boolean valid = key.reset();
                if (!valid) {
                    break;
                }
            }
        }).start();
    }

    private void scheduleFileExpiration(Path path) {
        scheduledExecutorService.schedule(() -> {
            try {
                Files.delete(path);
                System.out.println("Deleted file: " + path.getFileName());
                fileCreationTimes.remove(path);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }, expirationSeconds, TimeUnit.SECONDS);
    }
}

Основные изменения:

1. Используется WatchKey вместо повторного вызова FileSystems.getDefault().newWatchService() внутри цикла.