
import java.io.PrintStream;

public class ProgressBarService {

    private final String fileName;
    private final int totalSteps;
    private final PrintStream out;
    private int currentStep;

    public ProgressBarService(String fileName, int totalSteps) {
        this.fileName = fileName;
        this.totalSteps = totalSteps;
        this.out = System.out; // Поток вывода в консоль
        this.currentStep = 0;

        // Печатаем начальное состояние прогресса
        printProgressBar();
    }

    // Увеличиваем текущий шаг и обновляем прогрессбар
    public void step() {
        currentStep++;
        printProgressBar();
    }

    // Завершаем прогрессбар
    public void finish() {
        currentStep = totalSteps;
        printProgressBar();
        out.println(); // Перенос строки после завершения
    }

    // Печатаем прогрессбар в консоль
    private void printProgressBar() {
        StringBuilder bar = new StringBuilder();
        int progressWidth = 50; // Ширина прогрессбара (в символах)
        int filledWidth = (int) ((double) currentStep / totalSteps * progressWidth);

        bar.append("\rИмпорт файла ").append(fileName).append(" [");
        for (int i = 0; i < progressWidth; i++) {
            if (i < filledWidth) {
                bar.append("=");
            } else {
                bar.append(" ");
            }
        }
        bar.append("] ").append(String.format("%d%%", (int) ((double) currentStep / totalSteps * 100)));

        out.print(bar.toString());
    }
}












Если вы выполняете обработку всех батчей в одной транзакции, это объясняет проблему. Дело в том, что пока транзакция не завершена, процесс вставки данных фактически не выполняется, а ваш прогресс обновляется только после того, как вся операция завершена.

Чтобы корректно отображать прогресс, нужно учитывать следующее:

1. **Фактическая обработка должна быть разбита на шаги**: Если вы используете транзакцию, прогресс будет "заморожен", пока транзакция не завершится. Чтобы решить эту проблему, можно обновлять прогресс перед добавлением батча в транзакцию (но не коммитить данные до завершения всех шагов).

2. **Ограничить вывод на основе количества батчей**: Убедитесь, что прогрессбар обновляется на основе количества батчей, а не строк. 

---

### Обновленный подход

Модифицируем цикл вставки данных, чтобы обновление прогрессбара происходило после добавления каждого батча в транзакцию:

#### Изменения в `importCsvToDatabaseBatch`
```java
private boolean importCsvToDatabaseBatch(Path csvFilePath, String tableName, Connection connection, char delimiter) throws Exception {
    ProgressBarService progressBarService = new ProgressBarService(csvFilePath.getFileName().toString(), totalBatchCount); // totalBatchCount = (totalRows / BATCH_SIZE)

    try (Reader reader = Files.newBufferedReader(csvFilePath);
         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withDelimiter(delimiter).withFirstRecordAsHeader())) {
        
        List<String> headers = csvParser.getHeaderNames().stream()
                .flatMap(header -> splitHeader(header.trim()))
                .map(header -> "\"" + header.trim() + "\"")
                .collect(Collectors.toList());
        headers.add("\"iteration_id\"");

        String insertSQL = generateInsertSQL(tableName, headers);
        int iteration_id = getIterationId(csvFilePath);

        try (PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {
            List<CSVRecord> records = csvParser.getRecords();
            int count = 0;
            int totalBatchCount = (records.size() + BATCH_SIZE - 1) / BATCH_SIZE;

            for (CSVRecord record : records) {
                for (int i = 0; i < headers.size(); i++) {
                    String value = i == headers.size() - 1
                            ? String.valueOf(iteration_id)
                            : record.get(i);

                    if (!getIgnoreGaps().equals("active") && (value == null || value.trim().isEmpty())) {
                        description = "Пропуск данных";
                        return false;
                    }

                    if (i == headers.size() - 1) {
                        preparedStatement.setInt(i + 1, iteration_id);
                    } else {
                        preparedStatement.setString(i + 1, value);
                    }
                }
                preparedStatement.addBatch();
                count++;

                if (count % BATCH_SIZE == 0 || count == records.size()) {
                    preparedStatement.executeBatch();

                    // Обновляем прогресс после обработки каждого батча
                    progressBarService.step();
                }
            }
        }
    } catch (Exception e) {
        String message = "Ошибка при вставке данных: ";
        log.error(ExceptionFilter.unwindMessages(message, e));
        description = ExceptionFilter.unwindMessages(message, e);
        throw new Exception(message + e.getMessage(), e);
    }
    progressBarService.finish();
    return true;
}
```

---

### Что изменено:
1. **`ProgressBarService` обновляется на уровне батчей**: 
   - После каждого вызова `preparedStatement.executeBatch()` вызывается `progressBarService.step()`.

2. **Размер прогресса (`totalBatchCount`)**:
   - Вычисляется на основе количества строк, делённого на размер батча:
     ```java
     int totalBatchCount = (records.size() + BATCH_SIZE - 1) / BATCH_SIZE;
     ```

3. **Транзакция всё ещё целостная**:
   - Прогресс обновляется после добавления каждого батча, но сама транзакция завершится (с `commit`) только после завершения всей обработки. Это сохраняет консистентность данных.

4. **Финальная строка завершения**:
   - После завершения всех шагов вызывается `progressBarService.finish()`, чтобы явно завершить прогрессбар.

---

### Ожидаемое поведение:
- Прогрессбар обновляется после обработки каждого батча.
- В консоль выводится одна строка, которая постепенно заполняется в реальном времени.
- Прогрессбар завершает работу только после завершения всей транзакции. 

Попробуйте внести эти изменения, и прогрессбар будет корректно работать даже при транзакционной обработке.