package com.example.demo.services;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import com.example.demo.configurations.ParametersManager;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.nio.file.*;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Сервис для импортирования данных их csv файлов в бд Ois или Core
 */
@Service
public class FileImporterService {
    private static final Logger logger = LoggerFactory.getLogger(FileImporterService.class);
    private final ParametersManager parametersManager;
    private final String sourceDir;
    private final String processedDir;
    private static final int BATCH_SIZE = 1000;  // Размер батча для загрузки данных

    public FileImporterService(ParametersManager parametersManager,
                               @Value("${importer-properties.importerFolder}") String sourceDir,
                               @Value("${cleaner-properties.folderPath}") String processedDir) {
        this.parametersManager = parametersManager;
        this.sourceDir = sourceDir;
        this.processedDir = processedDir;
    }

    @Scheduled(fixedRate = 10000)  // Проверка каждые 10 секунд
    public void watchDirectory() {
        try {
            Path sourcePath = Paths.get(sourceDir);
            if (!Files.exists(sourcePath)) {
                logger.warn("Директория {} не существует", sourceDir);
                return;
            }

            Files.list(sourcePath)
                    .filter(Files::isRegularFile)
                    .forEach(filePath -> {
                        try {
                            logger.info("Обнаружен новый файл: {}", filePath);
                            if (filePath.toString().endsWith(".csv")) {
                                processCsvFile(filePath);
                            }
                        } catch (Exception e) {
                            logger.error("Ошибка при обработке файла {}", filePath, e);
                        }
                    });
        } catch (Exception e) {
            logger.error("Ошибка при наблюдении за директорией", e);
        }
    }

    private void processCsvFile(Path csvFilePath) throws Exception {
        String fileName = csvFilePath.getFileName().toString();
        String tableName = getTableNameWithoutExtension(fileName);

        try (Connection connection = getConnectionBasedOnFileName(fileName)) {
            logger.info("Импортируем файл {} в таблицу {}", fileName, tableName);

            char delimiter = detectDelimiter(csvFilePath);
            createTableFromCsv(csvFilePath, tableName, connection, delimiter);
            importCsvToDatabaseBatch(csvFilePath, tableName, connection, delimiter);
            moveFile(csvFilePath, Paths.get(processedDir));

            logger.info("Файл {} обработан и перемещен в {}", fileName, processedDir);
        } catch (Exception e) {
            logger.error("Ошибка при обработке файла {}", fileName, e);
        }
    }

    private String getTableNameWithoutExtension(String fileName) {
        String nameWithoutExtension = fileName.substring(0, fileName.lastIndexOf("."));
        return nameWithoutExtension.replaceAll("\\d+", "");  // Удаляем цифры из имени файла
    }

    private Connection getConnectionBasedOnFileName(String fileName) throws Exception {
        String dbUrl;
        String dbUsername;
        String dbPassword;

        if (fileName.toLowerCase().contains("ois")) {
            logger.info("Файл {} будет импортирован в базу данных OIS", fileName);
            dbUrl = parametersManager.getOisDbUrl();
            dbUsername = parametersManager.getDbOisUsername();
            dbPassword = parametersManager.getDbOisPassword();
        } else {
            logger.info("Файл {} будет импортирован в базу данных CORE", fileName);
            dbUrl = parametersManager.getCoreDbUrl();
            dbUsername = parametersManager.getDbCoreUsername();
            dbPassword = parametersManager.getDbCorePassword();
        }

        return DriverManager.getConnection(dbUrl, dbUsername, dbPassword);
    }

    private char detectDelimiter(Path csvFilePath) throws IOException {
        try (BufferedReader reader = Files.newBufferedReader(csvFilePath)) {
            String firstLine = reader.readLine();
            if (firstLine != null) {
                if (firstLine.contains(",")) {
                    return ',';
                } else if (firstLine.contains(";")) {
                    return ';';
                } else if (firstLine.contains("\t")) {
                    return '\t';
                } else {
                    throw new IllegalArgumentException("Не удалось определить разделитель для файла " + csvFilePath);
                }
            }
        }
        throw new IOException("Не удалось прочитать файл " + csvFilePath);
    }

    private void createTableFromCsv(Path csvFilePath, String tableName, Connection connection, char delimiter) throws Exception {
        try (Reader reader = Files.newBufferedReader(csvFilePath);
             CSVParser csvParser = CSVFormat.DEFAULT
                     .withFirstRecordAsHeader()
                     .withDelimiter(delimiter)
                     .parse(reader)) {

            List<String> headers = new ArrayList<>(csvParser.getHeaderMap().keySet());

            StringBuilder createTableQuery = new StringBuilder("CREATE TABLE IF NOT EXISTS ")
                    .append(tableName)
                    .append(" (");

            for (int i = 0; i < headers.size(); i++) {
                createTableQuery.append(headers.get(i).trim()).append(" TEXT");
                if (i < headers.size() - 1) {
                    createTableQuery.append(", ");
                }
            }
            createTableQuery.append(");");

            logger.info("Создание таблицы: {}", createTableQuery);

            try (Statement stmt = connection.createStatement()) {
                stmt.execute(createTableQuery.toString());
            }
        }
    }

    private void importCsvToDatabaseBatch(Path csvFilePath, String tableName, Connection connection, char delimiter) throws Exception {
        logger.info("Импорт данных в таблицу {} из файла {}", tableName, csvFilePath);

        try (Reader reader = Files.newBufferedReader(csvFilePath);
             CSVParser csvParser = CSVFormat.DEFAULT
                     .withFirstRecordAsHeader()
                     .withDelimiter(delimiter)
                     .parse(reader)) {

            List<String> headers = new ArrayList<>(csvParser.getHeaderMap().keySet());
            String insertQuery = generateInsertSQL(tableName, headers);

            try (PreparedStatement preparedStatement = connection.prepareStatement(insertQuery)) {
                int count = 0;

                for (CSVRecord record : csvParser) {
                    for (int i = 0; i < headers.size(); i++) {
                        preparedStatement.setString(i + 1, record.get(i));
                    }
                    preparedStatement.addBatch();

                    if (++count % BATCH_SIZE == 0) {
                        preparedStatement.executeBatch();
                    }
                }

                preparedStatement.executeBatch();  // Выполняем оставшиеся записи
            }
        }
    }

    private String generateInsertSQL(String tableName, List<String> headers) {
        String columns = headers.stream()
                .map(String::trim)
                .collect(Collectors.joining(", "));

        String placeholders = headers.stream()
                .map(header -> "?")
                .collect(Collectors.joining(", "));

        return String.format("INSERT INTO %s (%s) VALUES (%s)", tableName, columns, placeholders);
    }

    private void moveFile(Path source, Path targetDir) {
        try {
            Files.move(source, targetDir.resolve(source.getFileName()), StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            logger.error("Ошибка при перемещении файла {}", source.getFileName(), e);
        }
        logger.info("Файл перемещен в {}", targetDir);
    }
}
