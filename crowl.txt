Если прогресс-бар отображается только после завершения импорта, проблема кроется в следующем:

1. **Буферизация вывода консоли**: Вызов `System.out.print` откладывается до завершения долгой операции.
2. **Метод `update()` вызывается, но консоль не обновляется немедленно**.

Чтобы это исправить, я добавлю **принудительный вывод и flushing** консоли в каждой итерации, а также проверю, что вызов обновления прогресс-бара действительно происходит после каждого шага.

---

### Обновленный прогресс-бар

Теперь мы добавим **ручное управление потоками вывода** для реального времени.

```java
import java.io.PrintStream;
import java.util.concurrent.atomic.AtomicInteger;

public class ProgressBar {
    private final int barLength;
    private final String taskName;
    private final int totalSteps;
    private final AtomicInteger currentStep = new AtomicInteger(0);
    private volatile boolean running = true;

    private final PrintStream out;

    public ProgressBar(String taskName, int totalSteps, int barLength, PrintStream out) {
        this.taskName = taskName;
        this.totalSteps = totalSteps;
        this.barLength = barLength;
        this.out = out;
    }

    public void start() {
        Thread progressThread = new Thread(() -> {
            while (running) {
                printProgress();
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
            printProgress(); // Final progress update
            out.println();   // Move to the next line
        });
        progressThread.setDaemon(true);
        progressThread.start();
    }

    public void update(int completedSteps) {
        currentStep.set(completedSteps);
    }

    public void complete() {
        currentStep.set(totalSteps);
        running = false;
    }

    private void printProgress() {
        int completedSteps = currentStep.get();
        int percentage = (int) ((double) completedSteps / totalSteps * 100);
        int completedBars = (int) ((percentage / 100.0) * barLength);

        StringBuilder progress = new StringBuilder("\r") // Return to start of line
                .append(taskName)
                .append(" [");

        for (int i = 0; i < barLength; i++) {
            if (i < completedBars) {
                progress.append("█");
            } else {
                progress.append("░");
            }
        }

        progress.append("] ").append(percentage).append("%");
        out.print(progress.toString());
        out.flush(); // Force flush to ensure real-time output
    }
}
```

---

### Интеграция в метод `importCsvToDatabaseBatch`

Теперь интегрируем прогресс-бар, убедившись, что он обновляется при каждом выполнении батча:

```java
private boolean importCsvToDatabaseBatch(Path csvFilePath, String tableName, Connection connection, char delimiter) throws Exception {
    long totalRecords = fileIteration.getRows(); // Общее количество записей
    int totalSteps = (int) Math.ceil((double) totalRecords / BATCH_SIZE); // Количество шагов = количество батчей

    // Создаем прогресс-бар
    ProgressBar progressBar = new ProgressBar(
        "Импорт файла " + csvFilePath.getFileName(), totalSteps, 50, System.out);
    progressBar.start(); // Запускаем прогресс-бар

    try (Reader reader = Files.newBufferedReader(csvFilePath);
         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withDelimiter(delimiter).withFirstRecordAsHeader())) {

        List<String> headers = csvParser.getHeaderNames().stream()
                .flatMap(header -> splitHeader(header.trim()))
                .map(header -> "\"" + header.trim() + "\"")
                .collect(Collectors.toList());
        headers.add("\"iteration_id\"");
        String insertSQL = generateInsertSQL(tableName, headers);
        int iteration_id = getIterationId(csvFilePath);

        try (PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {
            List<CSVRecord> records = csvParser.getRecords();
            int count = 0;

            for (CSVRecord record : records) {
                for (int i = 0; i < headers.size(); i++) {
                    String value = i == headers.size() - 1 ? String.valueOf(iteration_id) : record.get(i);
                    if (!getIgnoreGaps().equals("active") && (value == null || value.trim().isEmpty())) {
                        description = "Пропуск данных";
                        return false;
                    } else {
                        if (i == headers.size() - 1) {
                            preparedStatement.setInt(i + 1, iteration_id);
                        } else {
                            preparedStatement.setString(i + 1, value);
                        }
                    }
                }

                preparedStatement.addBatch();
                count++;

                if (count % BATCH_SIZE == 0) {
                    preparedStatement.executeBatch();

                    // Обновляем прогресс-бар
                    int completedSteps = count / BATCH_SIZE;
                    progressBar.update(completedSteps);
                }
            }

            preparedStatement.executeBatch(); // Выполнение оставшихся записей
            if (count % BATCH_SIZE != 0) {
                int completedSteps = (int) Math.ceil((double) count / BATCH_SIZE);
                progressBar.update(completedSteps);
            }
        }
    } catch (Exception e) {
        String message = "Ошибка при импорте файла " + csvFilePath.getFileName() + ": ";
        log.error(message, e);
        throw new Exception(message, e);
    } finally {
        progressBar.complete(); // Завершаем прогресс-бар (100%)
    }

    return true;
}
```

---

### Почему это должно работать
1. **Принудительный вывод**:
   - `out.flush()` гарантирует немедленный вывод в консоль.

2. **Асинхронный прогресс**:
   - Прогресс-бар обновляется в отдельном потоке каждые 100 мс.
   - Метод `progressBar.update(completedSteps)` обновляет состояние для текущего числа завершенных шагов.

3. **Динамическое обновление**:
   - Каждое обновление перерисовывает одну и ту же строку с использованием `\r`.

---

### Ожидаемый вывод в консоли

Пример выполнения:

```
Импорт файла data.csv [██████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 20%
Импорт файла data.csv [███████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 50%
Импорт файла data.csv [███████████████████████░░░░░░░░░░░░░░░░░░░░░] 80%
Импорт файла data.csv [█████████████████████████████████████████████] 100%
```

Если вывод всё ещё задерживается, возможно, проблема в том, как обрабатываются ваши данные (например, блокировка в `executeBatch()`). В таком случае потребуется больше подробностей о вашей среде и данных.