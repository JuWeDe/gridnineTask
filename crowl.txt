Понял проблему, давайте исправим ситуацию.

Динамическое обновление прогресс-бара не работает, потому что `System.out.print()` с `\r` правильно работает только при своевременном выводе. Это может блокироваться следующими факторами:

1. **Буферизация вывода**: `System.out` по умолчанию буферизуется и выводится только при завершении программы или при явном вызове `flush()`.
2. **Блокировка цикла выполнения**: Прогресс-бар обновляется, но из-за долгих операций внутри цикла (`PreparedStatement.executeBatch()` и других) вывод задерживается.

Для исправления:

---

### Финальное решение: Динамический прогресс-бар

Мы сделаем так:
1. Используем отдельный поток для динамического обновления прогресс-бара.
2. Прогресс-бар будет обновляться в реальном времени по мере выполнения основной работы.
3. Все обновления будут видны в **одной строке** с перерисовкой.

---

### 1. Обновленный `ProgressBar`

```java
import java.util.concurrent.atomic.AtomicInteger;

public class ProgressBar {

    private final int barLength; // Длина прогресс-бара в символах
    private final String taskName; // Название задачи
    private final int totalSteps; // Общее количество шагов
    private final AtomicInteger currentStep = new AtomicInteger(0); // Текущий шаг выполнения

    private volatile boolean running = true; // Контроль для остановки прогресса

    public ProgressBar(String taskName, int totalSteps, int barLength) {
        this.taskName = taskName;
        this.totalSteps = totalSteps;
        this.barLength = barLength;
    }

    public void start() {
        Thread progressThread = new Thread(() -> {
            while (running) {
                printProgress();
                try {
                    Thread.sleep(100); // Обновляем прогресс каждые 100 мс
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
            // Завершающий вывод при остановке
            printProgress();
            System.out.println();
        });
        progressThread.setDaemon(true);
        progressThread.start();
    }

    public void update(int completedSteps) {
        currentStep.set(completedSteps);
    }

    public void complete() {
        currentStep.set(totalSteps);
        running = false;
    }

    private void printProgress() {
        int completedSteps = currentStep.get();
        int percentage = (int) ((double) completedSteps / totalSteps * 100);
        int completedBars = (int) ((percentage / 100.0) * barLength);

        StringBuilder progress = new StringBuilder();
        progress.append("\r") // Возвращаем каретку в начало строки
                .append(taskName)
                .append(" [");

        for (int i = 0; i < barLength; i++) {
            if (i < completedBars) {
                progress.append("█");
            } else {
                progress.append("░");
            }
        }

        progress.append("] ").append(percentage).append("%");

        System.out.print(progress.toString());
    }
}
```

---

### 2. Интеграция в метод `importCsvToDatabaseBatch`

Обновленный метод:

```java
private boolean importCsvToDatabaseBatch(Path csvFilePath, String tableName, Connection connection, char delimiter) throws Exception {
    long totalRecords = fileIteration.getRows(); // Общее количество записей
    int totalSteps = (int) Math.ceil((double) totalRecords / BATCH_SIZE); // Количество шагов = количество батчей

    // Создаем прогресс-бар
    ProgressBar progressBar = new ProgressBar("Импорт файла " + csvFilePath.getFileName(), totalSteps, 50);
    progressBar.start(); // Запускаем прогресс-бар в отдельном потоке

    try (Reader reader = Files.newBufferedReader(csvFilePath);
         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withDelimiter(delimiter).withFirstRecordAsHeader())) {

        List<String> headers = csvParser.getHeaderNames().stream()
                .flatMap(header -> splitHeader(header.trim()))
                .map(header -> "\"" + header.trim() + "\"")
                .collect(Collectors.toList());
        headers.add("\"iteration_id\"");
        String insertSQL = generateInsertSQL(tableName, headers);
        int iteration_id = getIterationId(csvFilePath);

        try (PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {
            List<CSVRecord> records = csvParser.getRecords();
            int count = 0;

            for (CSVRecord record : records) {
                for (int i = 0; i < headers.size(); i++) {
                    String value;
                    if (i == headers.size() - 1) {
                        value = String.valueOf(iteration_id);
                    } else {
                        value = record.get(i);
                    }
                    if (!getIgnoreGaps().equals("active") && (value == null || value.trim().isEmpty())) {
                        description = "Пропуск данных";
                        return false;
                    } else {
                        if (i == headers.size() - 1) {
                            preparedStatement.setInt(i + 1, iteration_id);
                        } else {
                            preparedStatement.setString(i + 1, value);
                        }
                    }
                }

                preparedStatement.addBatch();
                count++;

                if (count % BATCH_SIZE == 0) {
                    preparedStatement.executeBatch();

                    // Обновляем прогресс-бар
                    int completedSteps = count / BATCH_SIZE;
                    progressBar.update(completedSteps);
                }
            }

            preparedStatement.executeBatch(); // Выполнение оставшихся записей
            if (count % BATCH_SIZE != 0) {
                int completedSteps = (int) Math.ceil((double) count / BATCH_SIZE);
                progressBar.update(completedSteps);
            }
        }
    } catch (Exception e) {
        String message = "Ошибка при импорте файла " + csvFilePath.getFileName() + ": ";
        log.error(message, e);
        throw new Exception(message, e);
    } finally {
        progressBar.complete(); // Завершаем прогресс-бар (100%)
    }

    return true;
}
```

---

### Как это работает
1. **Асинхронное обновление прогресса**:
   - Прогресс-бар запускается в отдельном потоке (`progressBar.start()`).
   - Отдельный поток регулярно вызывает метод `printProgress`, перерисовывая строку в консоли.

2. **Обновление данных**:
   - После обработки каждого батча (внутри цикла) вызывается `progressBar.update(completedSteps)`.
   - Это позволяет обновлять состояние прогресс-бара на основе текущего числа завершенных шагов.

3. **Завершение**:
   - После завершения работы основной программы вызывается `progressBar.complete()`, чтобы остановить поток и завершить вывод.

---

### Пример вывода
Пример прогресса в терминале:

```
Импорт файла data.csv [██████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 40%
```

- Прогресс обновляется динамически, пока основной поток обрабатывает данные.

---

Если это не работает, напишите, и я сделаю дополнительные исправления!