private void processZipFile(Path zipFilePath) {
    String zipFileName = zipFilePath.getFileName().toString();
    boolean success = true;
    Path errorDirPath = Paths.get(errorDir);
    
    // Проверка полной загрузки архива
    if (isFileFullyUploaded(zipFilePath, 5, 2000)) {
        logger.error("Архив {} не загружен", zipFileName);
        updateFileIterations(zipFilePath.getFileName(), "error", errorDir, "Архив не загружен", new Timestamp(System.currentTimeMillis()));
        moveFile(zipFilePath, errorDirPath);
        return;
    }

    Path tempDir;
    try {
        tempDir = Files.createTempDirectory("zip_extract_");
    } catch (IOException e) {
        logger.error("Не удалось создать временную папку" + ExceptionFilter.displayError(e));
        updateFileIterations(zipFilePath.getFileName(), "error", errorDir, "Не удалось создать временную папку", new Timestamp(System.currentTimeMillis()));
        moveFile(zipFilePath, errorDirPath);
        return;
    }

    List<Path> extractedFiles = new ArrayList<>(); // Для хранения путей извлеченных файлов

    try (ZipInputStream zis = new ZipInputStream(Files.newInputStream(zipFilePath))) {
        ZipEntry zipEntry;

        // Обработка всех файлов архива
        while ((zipEntry = zis.getNextEntry()) != null) {
            if (zipEntry.getName().endsWith(".csv")) {
                // Извлекаем файл во временную директорию
                Path extractedFilePath = tempDir.resolve(zipEntry.getName());
                Files.createDirectories(extractedFilePath.getParent());  // Создаем директории, если не существуют
                Files.copy(zis, extractedFilePath, StandardCopyOption.REPLACE_EXISTING);
                extractedFiles.add(extractedFilePath);  // Добавляем файл в список извлеченных
            }
        }

        // Обрабатываем все извлеченные файлы параллельно
        CompletableFuture<Void> allTasks = CompletableFuture.allOf(
            extractedFiles.stream()
                .map(extractedFilePath -> CompletableFuture.runAsync(() -> {
                    processSingleCsvFile(zipFileName, extractedFilePath, errorDirPath);
                }))
                .toArray(CompletableFuture[]::new)
        );

        // Ждем завершения всех задач
        allTasks.join();

    } catch (IOException e) {
        logger.error("Ошибка при распаковке архива {}: {}", zipFileName, ExceptionFilter.displayError(e));
        success = false;
    } finally {
        try {
            Files.walk(tempDir)
                .sorted(Comparator.reverseOrder())
                .map(Path::toFile)
                .forEach(File::delete);  // Удаляем временную директорию

        } catch (IOException e) {
            logger.error("Ошибка при очистке временной папки {}:", tempDir + ExceptionFilter.displayError(e));
        }
    }

    // Если какой-либо файл не обработан успешно, помечаем архив как ошибочный
    if (!success) {
        updateFileIterations(zipFilePath.getFileName(), "error", errorDir, "Архив не обработан", new Timestamp(System.currentTimeMillis()));
        moveFile(zipFilePath, errorDirPath);
    } else {
        moveFile(zipFilePath, Paths.get(successDir));  // Перемещаем архив в success
    }
}

// Обработка одного CSV файла с транзакцией
private void processSingleCsvFile(String zipFileName, Path extractedFilePath, Path errorDirPath) {
    String fileName = extractedFilePath.getFileName().toString();
    String tableName = getTableNameWithoutExtension(fileName);
    boolean isTableCreated = false;
    Connection connection = null;

    try {
        if (isFileFullyUploaded(extractedFilePath, 5, 2000)) {
            logger.error("Файл {} из архива {} не загружен", extractedFilePath.getFileName(), zipFileName);
            throw new IllegalStateException("Файл не загружен полностью.");
        }

        logger.info("Импортируем файл {} в таблицу {}", fileName, tableName);

        char delimiter = detectDelimiter(extractedFilePath);

        // Получаем соединение для текущего файла
        connection = getConnectionBasedOnFileName(fileName);
        if (connection != null) {
            connection.setAutoCommit(false);  // Отключаем автокоммит для управления транзакцией вручную
        }

        // Проверяем существование таблицы и её столбцов
        if (!doesTableExist(connection, tableName)) {
            createTableFromCsv(extractedFilePath, tableName, connection, delimiter);
            isTableCreated = true;
        }

        // Импорт данных из CSV в таблицу
        boolean isImportSuccessful = importCsvToDatabaseBatch(extractedFilePath, tableName, connection, delimiter);
        if (!isImportSuccessful) {
            throw new SQLException("Ошибка данных в файле " + fileName);
        }

        if (connection != null) {
            connection.commit();  // Коммитим транзакцию, если все успешно
        }

    } catch (Exception e) {
        logger.error("Ошибка при обработке файла {} из архива {}: {}", fileName, zipFileName, e.getMessage());
        if (connection != null) {
            try {
                connection.rollback();  // Откат изменений при ошибке
                logger.info("Откат изменений для таблицы {} в архиве {}", tableName, zipFileName);

                if (isTableCreated) {
                    dropTableIfExists(connection, tableName);  // Удаляем таблицу, если она была создана
                }

            } catch (SQLException rollbackEx) {
                logger.error("Ошибка при откате изменений для таблицы {}: {}", tableName, ExceptionFilter.displayError(rollbackEx));
            }
        }
        moveFile(extractedFilePath, errorDirPath);  // Перемещаем файл в директорию ошибок
        throw new RuntimeException(e);  // Прерываем обработку архива
    } finally {
        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {
                logger.error("Ошибка при закрытии соединения для файла {}: {}", fileName, ExceptionFilter.displayError(e));
            }
        }
    }
}
