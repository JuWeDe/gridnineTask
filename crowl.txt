@Service
public class FolderCleaner {
    private static final Logger logger = LoggerFactory.getLogger(FolderCleaner.class);

    @Value("${cleaner-properties.folderPath}")
    private String watchedDirectoryPath;
    @Value("${cleaner-properties.daysCount}")
    private int daysCount;
    private final FileCategoryRepository fc;

    // Кэш для хранения информации о файлах
    private Map<String, Integer> fileExpirationCache = new HashMap<>();

    public FolderCleaner(FileCategoryRepository fc) {
        this.fc = fc;
    }

    @PostConstruct
    public void init() {
        loadFileCategoriesToCache();
    }

    private void loadFileCategoriesToCache() {
        // Загрузите данные из БД и заполните кэш
        // Примерный запрос для извлечения всех необходимых данных
        // Здесь предполагается, что в БД есть способ получить все уникальные комбинации масок и расширений
        // В реальном коде нужно будет реализовать соответствующий запрос и обработку
        List<FileCategory> categories = fc.getAllFileCategories();
        for (FileCategory category : categories) {
            fileExpirationCache.put(category.getNameMask() + "|" + category.getExtensions(), category.getDaysToExpire());
        }
    }

    @Scheduled(cron = "${cleaner-properties.schedulerCron}")
    public void cleanFolder() {
        Path watchedDirectory = Paths.get(watchedDirectoryPath);
        try {
            Files.list(watchedDirectory)
                    .forEach(this::deleteExpiredFile);
        } catch (IOException e) {
            logger.error("Ошибка при очистке директории: {}", e.getMessage());
        }
    }

    private void deleteExpiredFile(Path path) {
        String fileName = path.getFileName().toString();
        String fileExtension = fileName.substring(fileName.lastIndexOf(".") + 1);
        String fileMask = fileName.replaceAll("\\d", "").replace("." + fileExtension, "");

        Integer daysToExpire = fileExpirationCache.get(fileMask + "|" + fileExtension);
        
        if (daysToExpire != null && daysToExpire >= 0) {
            try {
                BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
                Instant creationInstant = attrs.creationTime().toInstant();
                LocalDateTime creationTime = LocalDateTime.ofInstant(creationInstant, ZoneId.systemDefault());
                long daysSinceCreation = ChronoUnit.DAYS.between(creationTime, LocalDateTime.now());
                
                if (daysSinceCreation > daysToExpire) {
                    Files.delete(path);
                    logger.info("Удален файл {}", fileName);
                }
            } catch (IOException e) {
                logger.error("Ошибка при удалении файла {}: {}", fileName, e.getMessage());
            }
        }
    }
}
