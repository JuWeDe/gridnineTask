Беседа № 126: 
Выбрана Ваша роль: Программист

Отлично, вот версия класса FolderCleaner без использования while(true):

import java.io.IOException;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class FolderCleaner {
    private final Path watchedDirectory;
    private final ScheduledExecutorService scheduledExecutorService;
    private final Map<Path, LocalDateTime> fileCreationTimes;
    private final int expirationSeconds;
    private final WatchService watchService;
    private final WatchKey watchKey;

    public FolderCleaner(String directoryPath, int expirationSeconds) throws IOException {
        this.watchedDirectory = Paths.get(directoryPath);
        this.expirationSeconds = expirationSeconds;
        this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();
        this.fileCreationTimes = new HashMap<>();

        // Регистрируем наблюдение за директорией
        this.watchService = FileSystems.getDefault().newWatchService();
        this.watchKey = watchedDirectory.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,
                StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);
    }

    public void start() {
        processWatchEvents();
    }

    private void processWatchEvents() {
        // Ожидание изменений в директории
        WatchKey key;
        try {
            key = watchService.take();
        } catch (InterruptedException e) {
            return;
        }

        // Обработка изменений
        for (WatchEvent<?> event : key.pollEvents()) {
            WatchEvent.Kind<?> kind = event.kind();
            Path path = watchedDirectory.resolve((Path) event.context());

            if (kind == StandardWatchEventKinds.ENTRY_CREATE) {
                // Новый файл создан
                fileCreationTimes.put(path, LocalDateTime.now());
                System.out.println("New file added: " + path.getFileName());
                scheduleFileExpiration(path);
            } else if (kind == StandardWatchEventKinds.ENTRY_DELETE) {
                // Файл удален
                fileCreationTimes.remove(path);
            } else if (kind == StandardWatchEventKinds.ENTRY_MODIFY) {
                // Файл изменен
                // Можно реализовать какие-либо действия, например, обновить метку времени
            } else if (kind == StandardWatchEventKinds.OVERFLOW) {
                // Пропущено событие, ничего не делаем
            }
        }

        // Сбрасываем ключ для дальнейшего использования
        boolean valid = key.reset();
        if (valid) {
            processWatchEvents();
        }
    }

    private void scheduleFileExpiration(Path path) {
        scheduledExecutorService.schedule(() -> {
            try {
                Files.delete(path);
                System.out.println("Deleted file: " + path.getFileName());
                fileCreationTimes.remove(path);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }, expirationSeconds, TimeUnit.SECONDS);
    }
}

Основные изменения:

1. Вызов processWatchEvents() вместо бесконечного цикла while(true).
2. Рекурсивный вызов processWatchEvents() после обработки событий.

Теперь, чтобы использовать этот класс, вы можете сделать следующее:

FolderCleaner folderCleaner = new FolderCleaner("path/to/directory", 10);
folderCleaner.start();