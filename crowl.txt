Ваши наблюдения могут быть связаны с несколькими проблемами:

1. **Прогресс-бар обновляется только после завершения задачи**: Это происходит, если операции ввода/вывода блокируют основной поток, и обновление прогресс-бара откладывается.
2. **Короткий прогресс-бар**: Это может быть связано с настройками ширины консоли или количеством шагов, которые вы передаете в `ProgressBar`.

Давайте исправим эти проблемы:

---

### Исправление 1: Обновление прогресс-бара в реальном времени

Чтобы прогресс-бар отображался корректно во время выполнения, нужно убедиться, что выполнение задачи не блокирует обновление консоли. Для этого можно использовать отдельный поток для отображения прогресса. Библиотека `ProgressBar` уже поддерживает это через асинхронный режим.

Добавим асинхронный прогресс-бар:

```java
try (ProgressBar progressBar = new ProgressBarBuilder()
        .setTaskName("Импорт файла")
        .setInitialMax(totalBatches) // Общее количество батчей
        .setUpdateIntervalMillis(100) // Обновление каждые 100 мс
        .setStyle(ProgressBarStyle.ASCII) // ASCII-стиль для простого вывода
        .build()) {
    
    // Логика обработки
    for (CSVRecord record : records) {
        // Обработка строк
        if (count % BATCH_SIZE == 0) {
            preparedStatement.executeBatch();
            progressBar.step(); // Обновляем прогресс
        }
    }

    // Если остались данные вне батча
    if (count % BATCH_SIZE != 0) {
        preparedStatement.executeBatch();
        progressBar.step();
    }
}
```

---

### Исправление 2: Увеличение длины прогресс-бара

По умолчанию длина прогресс-бара зависит от ширины консоли, но вы можете задать её вручную:

```java
try (ProgressBar progressBar = new ProgressBarBuilder()
        .setTaskName("Импорт файла")
        .setInitialMax(totalBatches) // Общее количество батчей
        .setUpdateIntervalMillis(100) // Обновление каждые 100 мс
        .setStyle(ProgressBarStyle.ASCII) // ASCII-стиль для простого вывода
        .setMaxRenderedLength(50) // Установка длины прогресс-бара
        .build()) {
    
    // Логика обработки
}
```

Укажите `setMaxRenderedLength(50)` или любое другое значение, чтобы прогресс-бар стал длиннее.

---

### Полный исправленный код

Вот обновленная функция `importCsvToDatabaseBatch` с прогресс-баром:

```java
private boolean importCsvToDatabaseBatch(Path csvFilePath, String tableName, Connection connection, char delimiter) throws Exception {
    long totalRecords = countLines(csvFilePath) - 1; // Общее количество строк без заголовка
    long totalBatches = (long) Math.ceil((double) totalRecords / BATCH_SIZE); // Количество батчей

    try (ProgressBar progressBar = new ProgressBarBuilder()
            .setTaskName("Импорт файла")
            .setInitialMax(totalBatches) // Устанавливаем общее количество батчей
            .setUpdateIntervalMillis(100) // Обновляем каждые 100 мс
            .setStyle(ProgressBarStyle.ASCII) // Стиль ASCII
            .setMaxRenderedLength(50) // Увеличиваем длину прогресс-бара
            .build();
         Reader reader = Files.newBufferedReader(csvFilePath);
         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withDelimiter(delimiter).withFirstRecordAsHeader())) {
        
        List<String> headers = csvParser.getHeaderNames().stream()
                .flatMap(header -> splitHeader(header.trim()))
                .map(header -> "\"" + header.trim() + "\"")
                .collect(Collectors.toList());
        headers.add("\"iteration_id\"");
        String insertSQL = generateInsertSQL(tableName, headers);
        int iteration_id = getIterationId(csvFilePath);

        try (PreparedStatement preparedStatement = connection.prepareStatement(insertSQL)) {
            List<CSVRecord> records = csvParser.getRecords();
            int count = 0;

            for (CSVRecord record : records) {
                for (int i = 0; i < headers.size(); i++) {
                    String value = i == headers.size() - 1 ? String.valueOf(iteration_id) : record.get(i);
                    if (!getIgnoreGaps().equals("active") && (value == null || value.trim().isEmpty())) {
                        description = "Пропуск данных";
                        return false;
                    } else {
                        if (i == headers.size() - 1) {
                            preparedStatement.setInt(i + 1, iteration_id);
                        } else {
                            preparedStatement.setString(i + 1, value);
                        }
                    }
                }
                preparedStatement.addBatch();
                count++;

                if (count % BATCH_SIZE == 0) {
                    preparedStatement.executeBatch();
                    progressBar.step(); // Обновляем прогресс-бар после выполнения батча
                }
            }
            if (count % BATCH_SIZE != 0) {
                preparedStatement.executeBatch();
                progressBar.step(); // Обновляем прогресс-бар для последнего батча
            }
        }
    } catch (Exception e) {
        String message = "importCsvToDatabaseBatch: Ошибка при batch вставке данных в бд -> ";
        log.error(ExceptionFilter.unwindMessages(message, e));
        description = ExceptionFilter.unwindMessages(message, e);
        throw new Exception(message + e.getMessage(), e);
    }
    return true;
}
```

---

### Результат

1. Прогресс-бар будет отображаться в одной строке.
2. Обновление будет происходить в реальном времени, без задержек.
3. Длина прогресс-бара будет контролируемой (например, 50 символов).

Если у вас всё еще будут вопросы или проблемы, дайте знать!