Если прогресс-бар обновляется только после полного импорта, то это может быть связано с тем, как обрабатывается вывод в консоль и с буферизацией `System.out`. В частности, `System.out.print` может не обновлять строку сразу из-за буферизации, либо проблема может быть связана с тем, что основной поток обработки блокируется до завершения цикла.

### Решение проблемы:
1. **Принудительный вывод с помощью `System.out.flush()`**:
   Используйте `System.out.flush()` после каждой записи в консоль, чтобы обновлять строку немедленно.

2. **Асинхронное обновление прогресса**:
   Если проблема связана с блокировкой основного потока, можно запускать обновление прогресса в отдельном потоке.

---

### Обновленный метод `print` с `flush`:
Обновим метод `print()` в `ProgressBar`:

```java
public void print() {
    int progress = (int) ((double) currentStep.get() / totalSteps * 100);
    int progressBars = progress / 2; // 50 символов в баре
    String bar = "=".repeat(progressBars) + " ".repeat(50 - progressBars);
    String progressLine = String.format("\rИмпорт файла (%s): [%s] %d%% (%d/%d)", 
                                        fileName, bar, progress, currentStep.get(), totalSteps);
    System.out.print(progressLine);
    System.out.flush(); // Принудительно обновляем вывод
    if (currentStep.get() >= totalSteps) {
        System.out.println(); // Завершаем строку при окончании
    }
}
```

---

### Обновление с использованием отдельного потока для прогресса
Иногда проблемы с отображением связаны с долгими вычислениями в основном потоке. В этом случае можно запустить прогресс-бар в отдельном потоке, который периодически обновляет строку.

#### Изменим `ProgressBarService` для асинхронной работы:
Добавим обновление прогресса в отдельном потоке:

```java
import java.util.concurrent.*;

public class ProgressBarService {
    private final ConcurrentHashMap<String, ProgressBar> progressBars = new ConcurrentHashMap<>();
    private final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);

    public void startProgress(String fileName, int totalSteps) {
        ProgressBar progressBar = new ProgressBar(fileName, totalSteps);
        progressBars.put(fileName, progressBar);

        // Запускаем периодическое обновление прогресса в отдельном потоке
        executorService.scheduleAtFixedRate(() -> {
            if (progressBar.isComplete()) {
                progressBars.remove(fileName);
            } else {
                progressBar.print();
            }
        }, 0, 100, TimeUnit.MILLISECONDS);
    }

    public void updateProgress(String fileName, int step) {
        ProgressBar progressBar = progressBars.get(fileName);
        if (progressBar != null) {
            progressBar.increment(step);
        }
    }

    public void completeProgress(String fileName) {
        ProgressBar progressBar = progressBars.get(fileName);
        if (progressBar != null) {
            progressBar.complete();
        }
    }

    public void shutdown() {
        executorService.shutdown();
    }

    private static class ProgressBar {
        private final String fileName;
        private final int totalSteps;
        private final AtomicInteger currentStep;
        private volatile boolean isComplete;

        public ProgressBar(String fileName, int totalSteps) {
            this.fileName = fileName;
            this.totalSteps = totalSteps;
            this.currentStep = new AtomicInteger(0);
            this.isComplete = false;
        }

        public void increment(int step) {
            currentStep.addAndGet(step);
        }

        public void complete() {
            currentStep.set(totalSteps);
            isComplete = true;
        }

        public boolean isComplete() {
            return isComplete;
        }

        public void print() {
            int progress = (int) ((double) currentStep.get() / totalSteps * 100);
            int progressBars = progress / 2; // 50 символов в баре
            String bar = "=".repeat(progressBars) + " ".repeat(50 - progressBars);
            String progressLine = String.format("\rИмпорт файла (%s): [%s] %d%% (%d/%d)", 
                                                fileName, bar, progress, currentStep.get(), totalSteps);
            System.out.print(progressLine);
            System.out.flush(); // Принудительно обновляем вывод
            if (isComplete) {
                System.out.println(); // Завершаем строку при окончании
            }
        }
    }
}
```

---

### Как использовать в методе импорта:
Теперь прогресс-бар будет обновляться каждые 100 мс независимо от выполнения основного цикла. Вызывайте методы `startProgress`, `updateProgress`, и `completeProgress` так же, как и раньше.

#### Завершение работы после импорта:
После завершения всех операций вызовите метод `shutdown()` у `ProgressBarService`:

```java
progressBarService.shutdown();
```

---

### Что изменилось:
1. Прогресс обновляется каждые 100 мс в отдельном потоке.
2. Строка в консоли отображается корректно, без задержки.
3. Буферизация решена с помощью `System.out.flush()`.