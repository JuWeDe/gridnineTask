package com.example.demo.service;

import com.example.demo.entities.FileCategory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class FileCategoryCacheService {

    private static final Logger logger = LoggerFactory.getLogger(FileCategoryCacheService.class);

    private final DataSource dataSource;
    private final ConcurrentHashMap<String, FileCategory> cache = new ConcurrentHashMap<>();

    public FileCategoryCacheService(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @PostConstruct
    public void initializeCache() {
        logger.info("Начало кэширования данных из таблицы file_categories...");
        
        try (Connection connection = dataSource.getConnection();
             PreparedStatement statement = connection.prepareStatement("SELECT * FROM file_categories");
             ResultSet resultSet = statement.executeQuery()) {

            List<FileCategory> categories = new ArrayList<>();
            while (resultSet.next()) {
                FileCategory fileCategory = new FileCategory();
                fileCategory.setId(resultSet.getInt("id"));
                fileCategory.setStatus(resultSet.getString("status"));
                fileCategory.setDescription(resultSet.getString("description"));
                fileCategory.setDatabase(resultSet.getString("database"));
                fileCategory.setStartDate(resultSet.getDate("start_date"));
                fileCategory.setFinishDate(resultSet.getDate("finish_date"));
                fileCategory.setDaysToExpire(resultSet.getInt("days_to_expire"));
                fileCategory.setSeparators(resultSet.getString("separators"));
                fileCategory.setColumnsCount(resultSet.getInt("columns_count"));
                fileCategory.setNameMask(resultSet.getString("name_mask"));
                fileCategory.setExtensions(resultSet.getString("extensions"));
                fileCategory.setColumns(resultSet.getString("columns"));

                // Кэшируем данные с ключом, основанным на name_mask и extensions
                cache.put(fileCategory.getNameMask() + "|" + fileCategory.getExtensions(), fileCategory);
                categories.add(fileCategory);
            }

            logger.info("Кэширование завершено. Всего категорий закэшировано: {}", categories.size());

        } catch (Exception e) {
            logger.error("Ошибка при кэшировании данных: ", e);
        }
    }

    // Получение категории из кэша по nameMask и extensions
    public FileCategory getCategoryByMaskAndExtension(String nameMask, String extensions) {
        return cache.get(nameMask + "|" + extensions);
    }

    // Получение всех закэшированных категорий
    public List<FileCategory> getAllCategories() {
        return new ArrayList<>(cache.values());
    }
}

package com.example.demo.cleaner;

import com.example.demo.entities.FileCategory;
import com.example.demo.service.FileCategoryCacheService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;

@Service
public class FolderCleaner {

    private static final Logger logger = LoggerFactory.getLogger(FolderCleaner.class);
    private final FileCategoryCacheService fileCategoryCacheService;

    public FolderCleaner(FileCategoryCacheService fileCategoryCacheService) {
        this.fileCategoryCacheService = fileCategoryCacheService;
    }

    public void deleteExpiredFile(Path path) {
        String fileName = path.getFileName().toString();
        logger.debug("Обработка файла: {}", fileName);

        String fileExtension = fileName.substring(fileName.lastIndexOf(".") + 1);
        String fileMask = fileName.replaceAll("\\d", "").replace("." + fileExtension, "");

        // Используем кэшированные данные из FileCategoryCacheService
        FileCategory category = fileCategoryCacheService.getCategoryByMaskAndExtension(fileMask, fileExtension);

        if (category != null) {
            int daysToExpire = category.getDaysToExpire();
            logger.info("Файл {} имеет срок жизни {} дней", fileName, daysToExpire);

            try {
                BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
                Instant creationInstant = attrs.creationTime().toInstant();
                LocalDateTime creationTime = LocalDateTime.ofInstant(creationInstant, ZoneId.systemDefault());
                long daysSinceCreation = ChronoUnit.DAYS.between(creationTime, LocalDateTime.now());

                if (daysSinceCreation > daysToExpire) {
                    Files.delete(path);
                    logger.info("Удален файл {}", fileName);
                } else {
                    logger.info("Файл {} еще не истек", fileName);
                }
            } catch (IOException e) {
                logger.error("Ошибка при удалении файла {}: {}", fileName, e.getMessage());
            }
        } else {
            logger.warn("Срок жизни для файла {} не найден", fileName);
        }
    }
}

