Беседа № 129: 
Выбрана Ваша роль: Программист

Понял, спасибо за дополнительные требования. Вот обновленное решение, которое выполняет все необходимые запросы за один раз:

package com.example.demo.services;

import com.example.demo.models.FileIteration;
import com.example.demo.repositories.FileIterationRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

@Service
public class FolderCleaner {
    private static final Logger logger = LoggerFactory.getLogger(FolderCleaner.class);

    private final Path watchedDirectory;
    private final FileIterationRepository fileIterationRepository;
    private final Map<Path, LocalDateTime> fileCreationTimes;

    /**
     * Конструктор класса FolderCleaner, в который передаются необходимые параметры.
     *
     * @param directoryPath             путь к директории, которую нужно очищать
     * @param fileIterationRepository   репозиторий для работы с таблицей file_iterations
     */
    public FolderCleaner(String directoryPath, FileIterationRepository fileIterationRepository) {
        this.watchedDirectory = Paths.get(directoryPath);
        this.fileIterationRepository = fileIterationRepository;
        this.fileCreationTimes = new HashMap<>();
    }

    /**
     * Метод, выполняющийся каждые 10 минут, который удаляет файлы из папки,
     * созданные более daysCount дней назад.
     */
    @Scheduled(cron = "0 */10 * ? * *")
    public void cleanFolder() {
        try {
            Files.list(watchedDirectory)
                 .forEach(this::deleteExpiredFile);
        } catch (IOException e) {
            logger.error("Ошибка при очистке директории: {}", e.getMessage());
        }
    }

    /**
     * Метод, который проверяет, удаляет ли файл, если он старше daysCount дней.
     *
     * @param path путь к файлу
     */
    private void deleteExpiredFile(Path path) {
        int daysCount = getExpireDaysForFile(path);

        if (daysCount > 0) {
            LocalDateTime creationTime = fileCreationTimes.getOrDefault(path, LocalDateTime.now().minusDays(daysCount + 1));
            long daysSinceCreation = ChronoUnit.DAYS.between(creationTime, LocalDateTime.now());

            if (daysSinceCreation > daysCount) {
                try {
                    Files.delete(path);
                    logger.info("Удален файл {}", path.getFileName());
                    fileCreationTimes.remove(path);
                } catch (IOException e) {
                    logger.error("Ошибка при удалении файла {}: {}", path.getFileName(), e.getMessage());
                }
            }
        }
    }

    /**
     * Метод, который получает количество дней, через которое файл должен быть удален,
     * на основе информации из таблицы file_iterations.
     *
     * @param path путь к файлу
     * @return количество дней, после которых файл будет удален
     */
    private int getExpireDaysForFile(Path path) {
        Optional<FileIteration> fileIterationOptional = fileIterationRepository.findByCategoryIdAndFileName(
                path.getFileName().toString());

        return fileIterationOptional.map(FileIteration::getDaysToExpire).orElse(0);
    }
}

В этом решении:

1. Добавлен FileIterationRepository, который должен быть реализован для работы с таблицей file_iterations в базе данных H2.