package com.example.demo.services;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import com.example.demo.configurations.ParametersManager;

import javax.annotation.PreDestroy;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.nio.file.*;
import java.sql.*;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Сервис для импортирования данных из csv файлов в бд Ois или Core
 */
@Service
public class FileImporterService {
    /** Логгер */
    private static final Logger logger = LoggerFactory.getLogger(FileImporterService.class);
    /** Параметры для подключения к бд */
    private final ParametersManager parametersManager;
    /** Путь до промежуточного файла хранения */
    private final String sourceDir;
    /** Путь до последнего файлового хранилища с подключенным FolderCleaner */
    private final String processedDir;
    /** Размер батча  */
    private static final int BATCHSIZE = 1000;

    // Множество для отслеживания обработанных файлов
    private final Set<String> processedFiles = ConcurrentHashMap.newKeySet();

    /**
     * Конструктор
     * @param parametersManager - экземпляр класса ParametersManager
     * @param sourceDir - путь до папки, куда поступают файлы
     * @param processedDir - путь до папки, в которую попадает файл после обработки
     */
    public FileImporterService(ParametersManager parametersManager,
                               @Value("${importer-properties.importerFolder}") String sourceDir,
                               @Value("${cleaner-properties.folderPath}") String processedDir) {
        this.parametersManager = parametersManager;
        this.sourceDir = sourceDir;
        this.processedDir = processedDir;
    }

    /**
     * Метод для мониторинга директории с файлами
     */
    @Scheduled(fixedRate = 10000) // Запуск каждые 10 секунд
    public void watchDirectory() {
        try {
            Path sourcePath = Paths.get(sourceDir);
            if (!Files.exists(sourcePath)) {
                logger.warn("Директория {} не существует", sourceDir);
                return;
            }

            Files.list(sourcePath)
                    .filter(Files::isRegularFile)
                    .forEach(filePath -> {
                        String fileName = filePath.getFileName().toString();
                        if (fileName.endsWith(".csv") && !processedFiles.contains(fileName)) {
                            logger.info("Обнаружен новый файл: {}", filePath);
                            processedFiles.add(fileName); // Добавляем файл в список обработанных
                            CompletableFuture.runAsync(() -> processCsvFile(filePath))
                                    .exceptionally(ex -> {
                                        logger.error("Ошибка при обработке файла {}", filePath, ex);
                                        processedFiles.remove(fileName); // Удаляем из списка, если произошла ошибка
                                        return null;
                                    });
                        }
                    });
        } catch (Exception e) {
            logger.error("Ошибка при наблюдении за директорией", e);
        }
    }

    /**
     * Метод для обработки csv файла
     * @param csvFilePath - путь до файла
     */
    private void processCsvFile(Path csvFilePath) {
        String fileName = csvFilePath.getFileName().toString();
        String tableName = getTableNameWithoutExtension(fileName);

        try (Connection connection = getConnectionBasedOnFileName(fileName)) {
            logger.info("Импортируем файл {} в таблицу {}", fileName, tableName);

            char delimiter = detectDelimiter(csvFilePath);
            createTableFromCsv(csvFilePath, tableName, connection, delimiter);
            importCsvToDatabaseBatch(csvFilePath, tableName, connection, delimiter);
            moveFile(csvFilePath, Paths.get(processedDir));
            logger.info("Файл {} обработан и перемещен в {}", fileName, processedDir);
        } catch (Exception e) {
            logger.error("Ошибка при обработке файла {}", fileName, e);
        }
    }

    // Остальные методы остаются без изменений
    // ...

    private void moveFile(Path source, Path targetDir) {
        try {
            Files.move(source, targetDir.resolve(source.getFileName()), StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            logger.error("Ошибка при перемещении файла {}", source.getFileName(), e);
        }
        logger.info("Файл перемещен в {}", targetDir);
    }

    @PreDestroy
    public void shutdown() {
        // Дополнительные действия по очистке, если необходимо
    }
}
