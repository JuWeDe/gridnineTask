private void processCsvFile(Path csvFilePath) throws SQLException {
    String fileName = csvFilePath.getFileName().toString();
    String tableName = getTableNameWithoutExtension(fileName);
    boolean isTableCreated = false;
    boolean fileHasErrors = false; // Флаг для отслеживания ошибок
    Connection connection = null;
    Path errorDirPath = Paths.get(errorDir);

    if (isFileFullyUploaded(csvFilePath, 5, 2000)) {
        logger.warn("Файл {} не был загружен полностью", csvFilePath.getFileName());
        moveFile(csvFilePath, errorDirPath);
        updateFileIterations(csvFilePath.getFileName(), "error", errorDir, new Timestamp(System.currentTimeMillis()));
        return;
    }

    try {
        connection = getConnectionBasedOnFileName(fileName);
        if (connection != null) {
            connection.setAutoCommit(false);
        }

        char delimiter = detectDelimiter(csvFilePath);

        // Проверяем существование таблицы
        if (!doesTableExist(connection, tableName)) {
            createTableFromCsv(csvFilePath, tableName, connection, delimiter);
            isTableCreated = true;
        }

        // Вставка данных в таблицу с проверкой на пропуски
        try (BufferedReader reader = Files.newBufferedReader(csvFilePath);
             CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withDelimiter(delimiter).withFirstRecordAsHeader())) {
             
            for (CSVRecord record : csvParser) {
                // Проверка на пропуски в строке
                if (record.isConsistent() && record.stream().anyMatch(String::isEmpty)) {
                    logger.warn("Пропуск в строке {}: {}", record.getRecordNumber(), record);
                    fileHasErrors = true;
                    throw new SQLException("Пропуски данных в строке: " + record.getRecordNumber());
                }
                // Вставляем запись в базу данных (можно использовать batch-операции)
                insertRecordIntoTable(record, tableName, connection);
            }
        }

        if (!fileHasErrors) {
            connection.commit();
            logger.info("Файл {} успешно импортирован", fileName);
            moveFile(csvFilePath, Paths.get(successDir));
            updateFileIterations(csvFilePath.getFileName(), "success", successDir, new Timestamp(System.currentTimeMillis()));
        }

    } catch (Exception e) {
        logger.warn("Ошибка при обработке файла {}: {}", fileName, e.getMessage());
        fileHasErrors = true;
        if (connection != null) {
            try {
                connection.rollback();
                logger.info("Откат транзакции для таблицы {}", tableName);
                if (isTableCreated) {
                    dropTableIfExists(connection, tableName);
                }
            } catch (SQLException rollbackEx) {
                logger.error("Ошибка отката транзакции: {}", rollbackEx.getMessage());
            }
        }
        updateFileIterations(csvFilePath.getFileName(), "error", errorDir, new Timestamp(System.currentTimeMillis()));
        moveFile(csvFilePath, errorDirPath);
    } finally {
        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {
                logger.error("Ошибка закрытия соединения: {}", e.getMessage());
            }
        }
    }
}



zipppp


private void processZipFile(Path zipFilePath) {
    String zipFileName = zipFilePath.getFileName().toString();
    boolean zipHasErrors = false; // Флаг для отслеживания ошибок в архиве
    Path errorDirPath = Paths.get(errorDir);

    if (isFileFullyUploaded(zipFilePath, 5, 2000)) {
        logger.warn("Архив {} не был загружен полностью", zipFileName);
        moveFile(zipFilePath, errorDirPath);
        updateFileIterations(zipFilePath.getFileName(), "error", errorDir, new Timestamp(System.currentTimeMillis()));
        return;
    }

    Path tempDir;
    try {
        tempDir = Files.createTempDirectory("zipextract_");
    } catch (IOException e) {
        logger.error("Не удалось создать временную папку для распаковки архива: {}", zipFileName);
        moveFile(zipFilePath, errorDirPath);
        return;
    }

    try (ZipInputStream zis = new ZipInputStream(Files.newInputStream(zipFilePath))) {
        ZipEntry zipEntry;
        Path successDirPath = Paths.get(successDir);
        
        while ((zipEntry = zis.getNextEntry()) != null) {
            if (zipEntry.getName().endsWith(".csv")) {
                Path extractedFile = tempDir.resolve(zipEntry.getName());
                Files.createDirectories(extractedFile.getParent());
                Files.copy(zis, extractedFile, StandardCopyOption.REPLACE_EXISTING);

                // Обработка CSV файла
                try {
                    processCsvFile(extractedFile);
                } catch (SQLException e) {
                    zipHasErrors = true;
                    logger.warn("Ошибка при обработке CSV файла {} из архива {}: {}", zipEntry.getName(), zipFileName, e.getMessage());
                }
            }
        }

        if (zipHasErrors) {
            // Если в архиве есть ошибки, перемещаем его в errorDir
            moveFile(zipFilePath, errorDirPath);
            updateFileIterations(zipFileName, "error", errorDir, new Timestamp(System.currentTimeMillis()));
        } else {
            moveFile(zipFilePath, successDirPath);
            updateFileIterations(zipFileName, "success", successDir, new Timestamp(System.currentTimeMillis()));
        }
        
    } catch (IOException e) {
        logger.warn("Ошибка при распаковке архива {}: {}", zipFileName, e.getMessage());
        moveFile(zipFilePath, errorDirPath);
    } finally {
        try {
            Files.delete(tempDir);
        } catch (IOException e) {
            logger.error("Ошибка при удалении временной папки {}: {}", tempDir, e.getMessage());
        }
    }
}
