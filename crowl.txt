private void processZipFile(Path zipFilePath) {
    String zipFileName = zipFilePath.getFileName().toString();
    boolean success = true;

    Path errorDirPath = Paths.get(errorDir);
    if (isFileFullyUploaded(zipFilePath, 5, 2000)) {
        logger.error("Архив {} не загружен полностью", zipFileName);
        moveFile(zipFilePath, errorDirPath);
        updateFileIterations(zipFilePath.getFileName(), "error", errorDir, new Timestamp(System.currentTimeMillis()));
        return;
    }

    Path tempDir;
    try {
        tempDir = Files.createTempDirectory("zip_extract_");
    } catch (IOException e) {
        logger.error("Не удалось создать временную папку: {}", ExceptionFilter.displayError(e));
        updateFileIterations(zipFilePath.getFileName(), "error", errorDir, new Timestamp(System.currentTimeMillis()));
        moveFile(zipFilePath, errorDirPath);
        return;
    }

    try (ZipInputStream zis = new ZipInputStream(Files.newInputStream(zipFilePath))) {
        ZipEntry zipEntry;
        List<CompletableFuture<Void>> futures = new ArrayList<>(); // Хранение задач по обработке файлов

        while ((zipEntry = zis.getNextEntry()) != null) {
            if (zipEntry.getName().endsWith(".csv")) {
                // Извлекаем файл во временную директорию
                Path extractedFile = tempDir.resolve(zipEntry.getName());
                Files.createDirectories(extractedFile.getParent()); // Создаем директории, если не существуют
                Files.copy(zis, extractedFile, StandardCopyOption.REPLACE_EXISTING);

                // Создаем CompletableFuture для каждого файла
                CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                    processSingleCsvFile(extractedFile, zipFileName, tempDir); // Обрабатываем каждый CSV файл
                }).exceptionally(ex -> {
                    logger.error("Ошибка при обработке файла {} из архива {}: {}", extractedFile.getFileName(), zipFileName, ex);
                    success = false;
                    return null;
                });

                futures.add(future); // Добавляем задачу в список
            }
        }

        // Ждем завершения всех задач
        CompletableFuture<Void> allOf = CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));
        allOf.join(); // Дожидаемся выполнения всех операций

        if (success) {
            Path successDirPath = Paths.get(successDir);
            moveFile(zipFilePath, successDirPath); // Перемещаем архив в папку успешных обработок
            updateFileIterations(zipFilePath.getFileName(), "success", successDir, new Timestamp(System.currentTimeMillis()));
        } else {
            moveFile(zipFilePath, errorDirPath); // Перемещаем в папку ошибок
            updateFileIterations(zipFilePath.getFileName(), "error", errorDir, new Timestamp(System.currentTimeMillis()));
        }
    } catch (IOException e) {
        logger.error("Ошибка при распаковке архива {}: {}", zipFileName, ExceptionFilter.displayError(e));
        success = false;
    } finally {
        // Удаляем временную директорию и файлы
        try {
            Files.walk(tempDir)
                .sorted(Comparator.reverseOrder())  // Удаляем сначала файлы, потом директорию
                .map(Path::toFile)
                .forEach(File::delete);
        } catch (IOException e) {
            logger.error("Ошибка при удалении временной папки {}: {}", tempDir, ExceptionFilter.displayError(e));
        }
    }
}
