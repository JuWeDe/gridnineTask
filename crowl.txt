package com.example.service;

import com.example.model.FileCategory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class FileCategoryCacheService {

    private static final Logger logger = LoggerFactory.getLogger(FileCategoryCacheService.class);

    private final DataSource dataSource;
    private final ConcurrentHashMap<String, FileCategory> cache = new ConcurrentHashMap<>();

    public FileCategoryCacheService(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @PostConstruct
    public void initializeCache() {
        logger.info("Начало кэширования категорий...");

        try (Connection connection = dataSource.getConnection();
             PreparedStatement statement = connection.prepareStatement("SELECT * FROM file_categories");
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                String nameMask = resultSet.getString("name_mask");
                String extensions = resultSet.getString("extensions");
                int daysToExpire = resultSet.getInt("days_to_expire");
                String description = resultSet.getString("description"); // Поле description
                boolean isActive = resultSet.getBoolean("is_active");     // Поле is_active

                FileCategory category = new FileCategory(nameMask, extensions, daysToExpire, description, isActive);
                cache.put(nameMask + "|" + extensions, category);
            }

            logger.info("Кэширование категорий завершено. Всего категорий: {}", cache.size());

        } catch (Exception e) {
            logger.error("Ошибка при кэшировании категорий", e);
        }
    }

    public FileCategory getCategoryByMaskAndExtension(String nameMask, String extension) {
        return cache.get(nameMask + "|" + extension);
    }

    public List<FileCategory> getAllCategories() {
        return List.copyOf(cache.values());
    }
}


folder cleaner 

package com.example.cleaner;

import com.example.model.FileCategory;
import com.example.service.FileCategoryCacheService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;

@Service
public class FolderCleaner {

    private static final Logger logger = LoggerFactory.getLogger(FolderCleaner.class);
    private final FileCategoryCacheService fileCategoryCacheService;

    public FolderCleaner(FileCategoryCacheService fileCategoryCacheService) {
        this.fileCategoryCacheService = fileCategoryCacheService;
    }

    public void deleteExpiredFile(Path path) {
        String fileName = path.getFileName().toString();
        logger.debug("Обработка файла: {}", fileName);

        String fileExtension = fileName.substring(fileName.lastIndexOf(".") + 1);
        String fileMask = fileName.replaceAll("\\d", "").replace("." + fileExtension, "");

        // Используем кэшированные данные из FileCategoryCacheService
        FileCategory category = fileCategoryCacheService.getCategoryByMaskAndExtension(fileMask, fileExtension);

        if (category != null) {
            int daysToExpire = category.getDaysToExpire();
            logger.info("Файл {} имеет срок жизни {} дней", fileName, daysToExpire);

            try {
                BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
                Instant creationInstant = attrs.creationTime().toInstant();
                LocalDateTime creationTime = LocalDateTime.ofInstant(creationInstant, ZoneId.systemDefault());
                long daysSinceCreation = ChronoUnit.DAYS.between(creationTime, LocalDateTime.now());

                if (daysSinceCreation > daysToExpire) {
                    Files.delete(path);
                    logger.info("Удален файл {}", fileName);
                } else {
                    logger.info("Файл {} еще не истек", fileName);
                }
            } catch (IOException e) {
                logger.error("Ошибка при удалении файла {}: {}", fileName, e.getMessage());
            }
        } else {
            logger.warn("Срок жизни для файла {} не найден", fileName);
        }
    }
}

