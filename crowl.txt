

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class ConfigManager {
    private static final String CONFIG_FILE = "config.properties";
    private static final long RELOAD_INTERVAL_SECONDS = 5;

    private static Properties config = new Properties();
    private static ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
    private static AtomicInteger changeCounter = new AtomicInteger(0);

    public static void main(String[] args) {
        // Установка начальных значений конфигурации
        загрузитьКонфигурацию();

        // Вывод начальных значений конфигурации
        System.out.println("Начальная конфигурация:");
        for (String key : config.stringPropertyNames()) {
            System.out.println(key + ": " + config.getProperty(key));
        }

        // Периодическое обновление конфигурации
        executorService.scheduleAtFixedRate(() -> {
            загрузитьКонфигурацию();
            int changes = проверитьИзмененияКонфигурации();
            if (changes > 0) {
                System.out.println("Конфигурация изменена " + changes + " раз(а).");
            }
        }, RELOAD_INTERVAL_SECONDS, RELOAD_INTERVAL_SECONDS, TimeUnit.SECONDS);

        // Имитация работы приложения
        while (true) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                break;
            }
        }
    }

    public static void загрузитьКонфигурацию() {
        try (FileInputStream fis = new FileInputStream(CONFIG_FILE)) {
            Properties newConfig = new Properties();
            newConfig.load(fis);
            config = newConfig;
        } catch (IOException e) {
            System.err.println("Ошибка загрузки конфигурации: " + e.getMessage());
        }
    }

    private static int проверитьИзмененияКонфигурации() {
        try (FileInputStream fis = new FileInputStream(CONFIG_FILE)) {
            Properties newConfig = new Properties();
            newConfig.load(fis);

            if (!newConfig.equals(config)) {
                int changes = changeCounter.incrementAndGet();
                System.out.println("Конфигурация изменена. Новое значение для ключа: " + newConfig.stringPropertyNames().iterator().next() + " = " + newConfig.getProperty(newConfig.stringPropertyNames().iterator().next()));
                config = newConfig;
                return changes;
            }
        } catch (IOException e) {
            System.err.println("Ошибка проверки конфигурации: " + e.getMessage());
        }
        return 0;
    }
}

В этом решении мы сделали следующее:

1. Использовали AtomicInteger для отслеживания количества изменений конфигурации.
2. В методе main() мы сразу после загрузки конфигурации выводим ее начальные значения.
3. В методе загрузитьКонфигурацию() мы просто присваиваем новую конфигурацию переменной config, без сравнения с предыдущей.
4. Мы добавили метод проверитьИзмененияКонфигурации(), который отвечает за проверку изменений конфигурации, и, если они произошли, выводит количество изменений и новое значение.

Теперь, когда вы запустите это приложение, оно будет каждые 5 секунд проверять файл config.properties на изменения и выводить соответствующие сообщения в консоль. Приложение будет работать постоянно, пока вы его не остановите.

Вы можете изменить значение параметра в файле config.properties, например: