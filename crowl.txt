
import java.io.IOException;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.Map;

public class FolderCleaner {
    private final Path watchedDirectory;
    private final int expirationDays;
    private final WatchService watchService;
    private final Map<WatchKey, Path> keyToPathMap;

    public FolderCleaner(String directoryPath, int expirationDays) throws IOException {
        this.watchedDirectory = Paths.get(directoryPath);
        this.expirationDays = expirationDays;
        this.watchService = FileSystems.getDefault().newWatchService();
        this.keyToPathMap = new HashMap<>();

        // Регистрируем наблюдение за директорией
        watchedDirectory.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,
                StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);
    }

    public void start() {
        new Thread(() -> {
            while (true) {
                // Ожидание изменений в директории
                WatchKey key;
                try {
                    key = watchService.take();
                } catch (InterruptedException e) {
                    return;
                }

                // Обработка изменений
                for (WatchEvent<?> event : key.pollEvents()) {
                    WatchEvent.Kind<?> kind = event.kind();
                    Path path = keyToPathMap.get(key).resolve((Path) event.context());

                    if (kind == StandardWatchEventKinds.ENTRY_CREATE) {
                        // Новый файл создан
                        keyToPathMap.put(key, path);
                    } else if (kind == StandardWatchEventKinds.ENTRY_DELETE) {
                        // Файл удален
                        keyToPathMap.remove(key);
                    } else if (kind == StandardWatchEventKinds.ENTRY_MODIFY) {
                        // Файл изменен
                        // Можно реализовать какие-либо действия, например, обновить метку времени
                    } else if (kind == StandardWatchEventKinds.OVERFLOW) {
                        // Пропущено событие, ничего не делаем
                    }
                }

                // Проверяем файлы на истечение срока годности
                checkExpiration();

                // Сбрасываем ключ для дальнейшего использования
                boolean valid = key.reset();
                if (!valid) {
                    keyToPathMap.remove(key);
                    if (keyToPathMap.isEmpty()) {
                        break;
                    }
                }
            }
        }).start();
    }

    private void checkExpiration() {
        for (Path path : keyToPathMap.values()) {
            LocalDateTime createdAt = Files.getLastModifiedTime(path).toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
            long daysSinceCreation = ChronoUnit.DAYS.between(createdAt, LocalDateTime.now());
            if (daysSinceCreation > expirationDays) {
                try {
                    Files.delete(path);
                    System.out.println("Deleted file: " + path.getFileName());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

Вот как можно использовать этот класс:

FolderCleaner folderCleaner = new FolderCleaner("path/to/directory", 30);
folderCleaner.start();